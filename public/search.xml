<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack系列之初探]]></title>
    <url>%2F2019%2F06%2F06%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[写在前面相信webpack这个名称对于前端的同学来说并不陌生，只要你在用vue、react等等之类的框架，就得天天和它打交道。但是大部分人都只是直接怼一个vue-cli脚手架生成一个项目，运行起来就开始一顿写，完全不会去看这个项目的其他相关的东西，今天开始，咱们就来说说这个又爱又恨的webpack 问题使用wepack的时候经常会出现下面这些疑问 你webpack只能打包单页面的文件吗？ WTF，我包怎么这么大，加载太慢了 我打包速度怎么这么慢，什么破玩意？… 为什么要使用webpack哈，你问我为什么要用？因为大家都在用啊😃😃。开个玩笑，前端发展到今天，新技术新思想新框架爆发式增长，当前的浏览器环境跑不赢啊，你说你写个ES6/7在浏览器环境都能跑起来？扯淡的。这个时候babel就出现了，你跑不起来是吧，那我转成ES5你总该跑起来吧~，那babel我还是不能直接用啊，肯定得借助工具编译呀，所以我们需要webpack去做这件事情了。这个时候有人就要站出来说了，我gulp不服，我也能做，我就不用webpack。你这么说我就要跟你唠唠了，现在我们先来比较一下webpack和gulp。 gulp 是 task runner，Webpack 是 module bundler webpack的优势在模块化，gulp除了模块化方面都很不错。但是前端发展至今，模块化真的很重要，CMD、AMD就是模块化的产物。简单来说，如果你当前项目需要模块化编程，那就选webpack，如果是处理其他事情，比如把图片拼接成雪碧图或者压缩，那么gulp是最擅长的 感兴趣的可以看看这个回答 gulp 有哪些功能是 webpack 不能替代的？ 安装这里可以参考webpack官网123&gt; mkdir webpack &amp;&amp; cd webpack&gt; npm init -y&gt; npm install webpack webpack-cli -D 入口（entry）每个webpack都会有一个entry，就是入口的意思，指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 注意点： 入口可以有多个，如果是单页面只需要一个入口，多页面可以设置多个路口 入口的文件必须是.js文件，因为webpack只认识js 举个🌰我们新建webpack.config.js和新建src文件夹，并且文件夹下新建index.js文件目录如下 1234- webpack/- src/- index.js- webpack.config.js webpack.config.js123module.exports = &#123; entry: './src/index.js'&#125;; 我们上面指定webpack的入口文件为index.js文件，这是总入口 出口（output）有入口当然就会有出口了，就是你导出的文件 webpack.config.js1234567module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; 上述entry已经介绍过了，我们来看看output，他有文件导出的路径（path）和导出的文件名（filename） 关于filename这里需要注意的地方有： 出口的文件名可以定制化，当前如果你是单页面的话，简单的可以写死一个filename，就如上面的bundle.js一样 你也可以这么写，使用入口名称的名称：filename: &#39;[name].bundle.js&#39;,当然还需要改一下entry，把它改成以下形式，name就会变成 -&gt; app 123456789module.exports = &#123; entry: &#123; app: './src/index.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; 现在我们来试一下webapck打包 小试牛刀第一步，新建一个文件夹webpack-demo123&gt; mkdir webpack-demo &amp;&amp; cd webpack-demo&gt; npm init -y&gt; cnpm install webpack webpack-cli -D 第二步，新建src/index.js文件和webpack.config.js文件 webpack.config.js 12345678const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist/'), &#125;,&#125;; index.js1document.write('hello webpack'); 第三步，打包命令行输入1&gt; npx webpack --config webpack.config.js 然后控制台就会输出12345678Hash: 348dca17387cd3f29cefVersion: webpack 4.33.0Time: 227msBuilt at: 2019-06-08 15:24:07 Asset Size Chunks Chunk Namesbundle.js 961 bytes 0 [emitted] mainEntrypoint main = bundle.js[0] ./src/index.js 33 bytes &#123;0&#125; [built] 看到这个信息证明你已经大功告成了，去看看dist/文件夹下是不是有打包好的js文件最后面你会看到有黄色的警告，说mode没有设置，待会再讲 这个时候你就会想，我每次生成的文件都叫bundle.js，我都区分不开，也不好做缓存，这个时候你就需要配置一下filename了 我们把webpack.config.js改成以下 12345678910const path = require('path');module.exports = &#123; entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;,&#125;; 然后执行1&gt; npx webpack --config webpack.config.js 这个时候dist/文件夹下就会多出个类似app.32434c7cc602e3049dac.js的文件，而且如果你反复执行打包命令，你发现app.32434c7cc602e3049dac.js文件名都没有改变，这是为什么呢？因为webpack会判断你的文件是否有更改而来觉得文件夹hash的变更，现在你可以尝试修改一下index.js文件之后打包的效果就知道了。 模式（mode ）上面说到每次打包的时候都会报警告，告诉我们没有设置mode，现在我们来说说mode首先mode有两个值，分别是development和production，意思就是，当前项目打包的开发环境还是生成环境的代码如果你设置了mode: ‘development’，在项目里你可以使用 process.env.NODE_ENV 来获取当前的环境的值你可以尝试把webpack.config.js改成以下，然后在index.js里把这个值打印出来，运行一下效果 webpack.config.js1234567891011const path = require('path');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;,&#125;; index.js1document.write(`hello webpack，this is $&#123;process.env.NODE_ENV&#125;`); 现在我们只有js文件，你可以先在根目录新建一个index.html文件，把js引入在浏览器环境执行(或者直接在浏览器控制台执行js)，你会看到浏览器显示 -&gt; hello webpack，this is development你分别运行之后会发现他们的效果是不一样的，一个是被压缩的，一个没有被压缩 这个时候你就会想了，怎么这么麻烦，我打包还得自己去新建html文件引入js然后运行或者去执行js文件，能不能让他自动运行跑起来？当然是可以的，下面我们来说说plugins## 插件（plugins）插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！（官网的解释）插件怎么说呢？不好解释它，你可以理解为处理工具，插件目的在于解决 loader(这个等会再讲，现在用不上) 无法实现的其他事插件怎么配置？就像下面这样，当然不是随便找的插件，我们会用到下面配置的插件123456789101112131415const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: 'index.html'&#125;) ]&#125;;我们先在根目录新建一个index.html文件，之前不是说运行项目很麻烦嘛？现在教你简单的方法然后我们用到了html-webpack-plugin，需要先安装他才能使用1&gt; cnpm i html-webpack-plugin -D下一步打包运行项目1&gt; npx webpack --config webpack.config.js运行结果：12345678910111213141516Hash: bea857ae13cad8af6e66Version: webpack 4.33.0Time: 274msBuilt at: 2019-06-08 16:00:33 Asset Size Chunks Chunk Namesapp.bea857ae13cad8af6e66.js 3.83 KiB app [emitted] app index.html 74 bytes [emitted] Entrypoint app = app.bea857ae13cad8af6e66.js[./src/index.js] 65 bytes &#123;app&#125; [built]Child html-webpack-plugin for &quot;index.html&quot;: 1 asset Entrypoint undefined = index.html [./node_modules/_html-webpack-plugin@3.2.0@html-webpack-plugin/lib/loader.js!./index.html] 209 bytes &#123;0&#125; [built] [./node_modules/_webpack@4.33.0@webpack/buildin/global.js] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built] [./node_modules/_webpack@4.33.0@webpack/buildin/module.js] (webpack)/buildin/module.js 497 bytes &#123;0&#125; [built] + 1 hidden module去查看dist文件夹下，你会发现多出了两个文件，js和index.html文件，这就是插件的功劳html-webpack-plugin这个插件需要指定是那个html模板，然后最后打包的时候就是以这个模板为主，把打包好的js文件放到这个index.html里面，你可以查看html文件里的内容：index.html1&lt;script type="text/javascript" src="app.1b0b2001b0579faec32d.js"&gt;&lt;/script&gt;这个时候你会发现，我靠，我dist文件怎么这么多啊，怎么办啊？别急，我们再来用一个插件解决这个问题 安装插件clean-webpack-plugin1&gt; cnpm i clean-webpack-plugin -D 然后配置文件去添加插件 1234567891011121314151617const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123;template: 'index.html'&#125;) ]&#125;; 然后你再去看看dist文件夹里的文件，是不是只有两个文件了？这个插件的作用是，先把dist文件夹里的文件先清空然后再把打包好的文件放入dist。 那么你还会有问题，这还是麻烦啊，我不能只运行命令行，让重新自己打开浏览器运行我打包的项目吗？当然可以啊首先安装 webpack-dev-server1&gt; cnpm i webpack-dev-server -D然后1&gt; webpack-dev-server --open --config webpack.config.js你会发现重新自动打开了浏览器，页面显示 hello webpack，this is development。是不是很简单？你现在可以去修改index.js然后保存文件，去浏览器看看是不是自动刷新了你刚刚更改的内容呢？现在你可能还会有问题，我去，这太简单了吧，我要用css和图片怎么办？js不能导入css文件啊！我怎么跟vue一样在自己的ip访问项目啊？现在肯定是问题一大堆 loaderloader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。比如可以把typescript转换成JavaScript，less转成css现在我们就来解决你上一章节末的问题，教你配置简单的loader，来加载css或者图片首先我们先安装css-loader/style-loader，来加载解析css文件1&gt; cnpm i css-loader style-loader -D 下一步在src文件夹下新建test.css文件，再在index.js导入test.css123body &#123; background: #ccc;&#125; index.js12import './test.css';document.write(`hello webpack，this is $&#123;process.env.NODE_ENV&#125;，test`); 如果你直接运行会发现控制台报错了1234567ERROR in ./src/test.css 1:5Module parse failed: Unexpected token (1:5)You may need an appropriate loader to handle this file type.&gt; body &#123;| background: #ccc;| &#125; @ ./src/index.js 1:0-20 这个时候loader登场了，我们修改配置文件webpack.config.js12345678910111213141516171819202122232425const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; template: 'index.html' &#125;), ], module: &#123; rules:[ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'], &#125;, ] &#125;&#125;; 然后运行命令行1&gt; webpack-dev-server --open --config webpack.config.js 你会发现页面背景颜色变了 现在我们来说说配置：module.rules 允许你在 webpack 配置中指定多个 loader，上面我们规定正则匹配css文件，然后如果匹配到了，则使用style-laoder和css-loader去处理css文件，css-laoder负责解析css文件，style-loader负责把css文件放到页面中去，你打开调试可以看到head里被插入了style样式标签，当前如果你想解析例如xx.ts文件，则可以在数组里面新增：1234 &#123; test: /\.ts$/, use: 'ts-loader',&#125;, 下面来看看怎么加载图片资源，还是跟上述原一样，图片也是有类型的，我们首先得匹配文件后缀，然后去用loader去解析他们，这里我们需要用到 url-loader file-loader按照惯例先安装1&gt; cnpm i url-loader file-loader -D 12345678910111213141516171819module.exports = &#123; ... module: &#123; rules:[ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'], &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 6000, name: 'img/[name].[hash:7].[ext]', &#125;, &#125; ] &#125;&#125;; 下一步就是往项目里增加图片了我们修改test.css文件test.css123body &#123; background: url(img.jpg);&#125; 浏览器就显示的全是刚刚设置的重复图片了 这里你又会问了，不对，你这里只用到了url-loader，file-loader不是多余的吗？ 不是的，你可以看看options，有一个limit参数，规定如果超过了6000bytes大小的文件会交给file-loader处理，因为如果图片小于这个数值，url-loader会把图片转成base64格式的图片加载，如果超过就自己不处理了，所以他们两者是有相依性的 使用npm脚本上面基本上都是使用一大段的命令行来执行项目，现在我们来简化一下修改package.json1234"scripts": &#123; "dev": "webpack-dev-server --open --config webpack.config.js", "build": "webpack --config webpack.config.js"&#125;, 命令行运行项目12&gt; npm run dev&gt; npm run build devServer在开发中你可能有很多需求，比如怎么通过ip访问项目，怎么把控制台信息输出的精简点，怎么修改端口等等？这个时候就需要用到devServer的配置了我们修改webpack.config.js,增加以下： 1234567891011module.exports = &#123; ... devServer: &#123; contentBase: './dist', // 告诉服务器从哪里提供内容 host: '0.0.0.0', // 指定使用一个 host。默认是 localhost useLocalIp: true, // 是否使用本地ip open: true, // 是否自动打开浏览器 port: 8080, // 端口号 noInfo: true, // 显示的 webpack 包(bundle)信息」的消息将被隐藏 &#125;,&#125; 是的，你现在可以不用在命令行里增加–open这个参数，在这里配置也是一样的 最后累了累了，写到这已经是凌晨了。不多BB了，现在基本的webpack操作应该都已经学会了吧，后面就是稍微深入的玩一玩webpack了，成为一个webpack配置工程师？ to be continued…]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis简易教程以及使用nodejs连接redis]]></title>
    <url>%2F2019%2F04%2F19%2Fredis%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8nodejs%E8%BF%9E%E6%8E%A5redis%2F</url>
    <content type="text"><![CDATA[前言一直没机会学习redis，最近抽空学了一下，因为知道reids还是比较重要的，经常看到有人开发公众号因为没有对access_token进行缓存，判断是否过期，导致access_token的调用api次数超过限制而影响业务的情况，熟悉的人都知道使用redis基本上都是做缓存，因为他简单、速度快，可以说是个”快男”。使用reids做抽奖也很普遍，有空可以试试。本篇本章暂时只讲key、hash、list redis简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 为什么要用redis（优势） 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 安装运行及调试（这里以mac为例） 先去官网下载安装包：http://www.redis.net.cn/download/ 解压安装 12345&gt; tar xzf redis-3.0.6.tar.gz&gt; make&gt; sudo make install&gt; cd /usr/local/bin &amp;&amp; redis-server // 开启redis服务&gt; cd /usr/local/bin &amp;&amp; redis-cli // 开启redis调试服务 开启调试会显示下面的界面，现在你就可以开始使用redis的api了12&gt; cd /usr/local/bin &amp;&amp; redis-cli127.0.0.1:6379&gt; 全局api查询键123456127.0.0.1:6379&gt; keys *1) &quot;wclimb&quot;2) &quot;key&quot;3) &quot;me&quot;4) &quot;user&quot;5) &quot;user1&quot; 键的总数12127.0.0.1:6379&gt; dbsize (integer) 5 检查键是否存在存在返回 1 ，不存在返回 01234127.0.0.1:6379&gt; exists wclimb (integer) 1127.0.0.1:6379&gt; exists wclimb1 (integer) 0 删除键返回结果为成功删除键的个数12127.0.0.1:6379&gt; del user1 (integer) 1 键过期expire key seconds 当超过过期时间，会自动删除，key在seconds秒后过期expireat key timestamp 键在秒级时间戳timestamp后过期pexpire key milliseconds 当超过过期时间，会自动删除，key在milliseconds毫秒后过期pexpireat key milliseconds-timestamp key在毫秒级时间戳timestamp后过期 12127.0.0.1:6379&gt; expire user 10 // 10秒后user会被删除(integer) 1 randomkey 随机返回一个键1234127.0.0.1:6379&gt; randomkey &quot;wclimb&quot;127.0.0.1:6379&gt; randomkey &quot;me&quot; redis 键（key）123456set key value [ex] [px] [nx|xx]ex为键值设置秒级过期时间px为键值设置毫秒级过期时间nx键必须不存在，才可以设置成功，用于添加xx与nx相反，键必须存在，才可以设置成功，用于更新setnx、setex 与上面的nx、ex作用相同 设置key(O(1))1234567127.0.0.1:6379&gt; set name 25 OK127.0.0.1:6379&gt; keys * 1) &quot;wclimb&quot;2) &quot;key&quot;3) &quot;me&quot;4) &quot;name&quot; 获取key(O(1))12127.0.0.1:6379&gt; get name &quot;25&quot; 批量设置keymset key value [key value ……] 1234127.0.0.1:6379&gt; mset test1 1 test2 2OK127.0.0.1:6379&gt; get test2&quot;2&quot; 追加值(O(1))1234127.0.0.1:6379&gt; append test2 apend(integer) 6127.0.0.1:6379&gt; get test2 &quot;2apend&quot; 字符串长度12127.0.0.1:6379&gt; strlen test2(integer) 6 哈希（hash）HGET KEY_NAME FIELD_NAME类似javscript里的对象 {} 设置hash12127.0.0.1:6379&gt; HMSET hash name wclimb age 25OK 获取hash12127.0.0.1:6379&gt; hmget hash name1) &quot;wclimb&quot; 删除hashhdel key field [field ……] 会删除一个或多个field，返回结果为成功删除fiel的个数 1234127.0.0.1:6379&gt; hdel hash name(integer) 1127.0.0.1:6379&gt; hmget hash name // 再获取就返回nil1) (nil) 获取所有field12345678127.0.0.1:6379&gt; hkeys hash1) &quot;age&quot;127.0.0.1:6379&gt; HMSET hash name wclimb from jiangxiOK127.0.0.1:6379&gt; hkeys hash1) &quot;age&quot;2) &quot;name&quot;3) &quot;from&quot; 获取所有value1234127.0.0.1:6379&gt; hvals hash1) &quot;25&quot;2) &quot;wclimb&quot;3) &quot;jiangxi&quot; 列表（list） 操作类型 操作 添加 rpush 、lpush、linsert 查 lrange、lindex、llen 删除 lpop 、rpop、 lrem、ltrim 修改 lset 阻塞操作 blpop、brpop 添加（1）从左边插入元素lpush key value [value……]12127.0.0.1:6379&gt; LPUSH list redis(integer) 1 （1）从右边插入元素rpush key value [value……]12127.0.0.1:6379&gt; RPUSH list test(integer) 2 查找lrange key start end 索引下标从左到右分别是0到N-1，从右到左分别是-1到-N；end选项包含了自身lrange key 0 -1 可以从左到右获取列表的所有元素lrange mylist 1 3 获取列表中第2个到第4个元素 123127.0.0.1:6379&gt; lrange list 0 11) &quot;redis&quot;2) &quot;test&quot; 长度12127.0.0.1:6379&gt; llen key(integer) 2 删除我们先添加几个 12127.0.0.1:6379&gt; LPUSH list a b c(integer) 5 （1）从列表右侧弹出元素 rpop key （2）从列表左侧弹出元素 lpop key 先看看现在的列表123456127.0.0.1:6379&gt; lrange list 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;redis&quot;5) &quot;test&quot; 删除12127.0.0.1:6379&gt; rpop list &quot;test&quot; 我们发现test被删除了，现在看看我们的列表12345127.0.0.1:6379&gt; lrange list 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;redis&quot; 修改lset key index newValue 修改指定索引下标的元素 1234567127.0.0.1:6379&gt; lset list 0 newValueOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;newValue&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;redis&quot; 第0个下标的元素被替换成最新的值 使用node连接redis1234&gt; npm init&gt; cnpm i reids -S&gt; touch index.js&gt; vim index.js 连接redisredis npm包链接 https://www.npmjs.com/package/redis 123456var redis = require('redis');var client = redis.createClient(6379, '127.0.0.1');client.on('error', function(err) &#123; console.log('Error ' + err);&#125;); 设置获取key123456client.set('user', JSON.stringify(&#123; name: 'wclimb', age: '18' &#125;), redis.print);client.get('user', function(err, value) &#123; if (err) throw err; console.log('Got: ' + value); client.quit();&#125;); 控制台打印 123&gt; node index.jsReply: OKGot: &#123;&quot;name&quot;:&quot;wclimb&quot;,&quot;age&quot;:&quot;18&quot;&#125; 设置获取hash1234client.hmset("hosts", "mjr", "1", "another", "23", "home", "1234");client.hgetall("hosts", function (err, obj) &#123; console.dir(obj);&#125;); 控制台打印12&gt; node index.js&#123; mjr: &apos;1&apos;, another: &apos;23&apos;, home: &apos;1234&apos; &#125; 设置获取list12client.LPUSH('list', [1, 2, 3, 4], redis.print);client.lrange('list', '0', '-1', redis.print); 控制台打印123&gt; node index.jsReply: 8Reply: 4,3,2,1,newValue,b,a,redis 基本用法和上面讲的都差不多，直接上去一顿写就完事了，完全可以不带脑子的使用各种api]]></content>
      <categories>
        <category>javascript</category>
        <category>redis</category>
        <category>node</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之实现一个简单的Vue]]></title>
    <url>%2F2018%2F09%2F11%2FJavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vue%2F</url>
    <content type="text"><![CDATA[vue的使用相信大家都很熟练了，使用起来简单。但是大部分人不知道其内部的原理是怎么样的，今天我们就来一起实现一个简单的vue Object.defineProperty()实现之前我们得先看一下Object.defineProperty的实现，因为vue主要是通过数据劫持来实现的，通过get、set来完成数据的读取和更新。 1234567891011121314151617181920var obj = &#123;name:'wclimb'&#125;var age = 24Object.defineProperty(obj,'age',&#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get () &#123; return age &#125;, set (newVal) &#123; console.log('我改变了',age +' -&gt; '+newVal); age = newVal &#125;&#125;)&gt; obj.age&gt; 24&gt; obj.age = 25;&gt; 我改变了 24 -&gt; 25&gt; 25 从上面可以看到通过get获取数据，通过set监听到数据变化执行相应操作，还是不明白的话可以去看看Object.defineProperty文档。 流程图 html代码结构1234567&lt;div id=&quot;wrap&quot;&gt; &lt;p v-html=&quot;test&quot;&gt;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;form&quot;&gt; &lt;button @click=&quot;changeValue&quot;&gt;改变值&lt;/button&gt; &#123;&#123;form&#125;&#125;&lt;/div&gt; js调用12345678910111213new Vue(&#123; el: '#wrap', data:&#123; form: '这是form的值', test: '&lt;strong&gt;我是粗体&lt;/strong&gt;', &#125;, methods:&#123; changeValue()&#123; console.log(this.form) this.form = '值被我改变了，气不气？' &#125; &#125;&#125;) Vue结构1234567891011class Vue&#123; constructor()&#123;&#125; proxyData()&#123;&#125; observer()&#123;&#125; compile()&#123;&#125; compileText()&#123;&#125;&#125;class Watcher&#123; constructor()&#123;&#125; update()&#123;&#125;&#125; Vue constructor 构造函数主要是数据的初始化 proxyData 数据代理 observer 劫持监听所有数据 compile 解析dom compileText 解析dom里处理纯双花括号的操作 Watcher 更新视图操作 Vue constructor 初始化1234567891011121314class Vue&#123; constructor(options = &#123;&#125;)&#123; this.$el = document.querySelector(options.el); let data = this.data = options.data; // 代理data，使其能直接this.xxx的方式访问data，正常的话需要this.data.xxx Object.keys(data).forEach((key)=&gt; &#123; this.proxyData(key); &#125;); this.methods = options.methods // 事件方法 this.watcherTask = &#123;&#125;; // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom &#125;&#125; 上面主要是初始化操作，针对传过来的数据进行处理 proxyData 代理data123456789101112131415161718class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; let that = this; Object.defineProperty(that, key, &#123; configurable: false, enumerable: true, get () &#123; return that.data[key]; &#125;, set (newVal) &#123; that.data[key] = newVal; &#125; &#125;); &#125; &#125; 上面主要是代理data到最上层，this.xxx的方式直接访问data observer 劫持监听123456789101112131415161718192021222324252627282930class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data)&#123; let that = this Object.keys(data).forEach(key=&gt;&#123; let value = data[key] this.watcherTask[key] = [] Object.defineProperty(data,key,&#123; configurable: false, enumerable: true, get()&#123; return value &#125;, set(newValue)&#123; if(newValue !== value)&#123; value = newValue that.watcherTask[key].forEach(task =&gt; &#123; task.update() &#125;) &#125; &#125; &#125;) &#125;) &#125; &#125; 同样是使用Object.defineProperty来监听数据，初始化需要订阅的数据。把需要订阅的数据到push到watcherTask里，等到时候需要更新的时候就可以批量更新数据了。👇下面就是；遍历订阅池，批量更新视图。123456789set(newValue)&#123; if(newValue !== value)&#123; value = newValue // 批量更新视图 that.watcherTask[key].forEach(task =&gt; &#123; task.update() &#125;) &#125;&#125; compile 解析dom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data)&#123; ...... &#125; compile(el)&#123; var nodes = el.childNodes; for (let i = 0; i &lt; nodes.length; i++) &#123; const node = nodes[i]; if(node.nodeType === 3)&#123; var text = node.textContent.trim(); if (!text) continue; this.compileText(node,'textContent') &#125;else if(node.nodeType === 1)&#123; if(node.childNodes.length &gt; 0)&#123; this.compile(node) &#125; if(node.hasAttribute('v-model') &amp;&amp; (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA'))&#123; node.addEventListener('input',(()=&gt;&#123; let attrVal = node.getAttribute('v-model') this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'value')) node.removeAttribute('v-model') return () =&gt; &#123; this.data[attrVal] = node.value &#125; &#125;)()) &#125; if(node.hasAttribute('v-html'))&#123; let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'innerHTML')) node.removeAttribute('v-html') &#125; this.compileText(node,'innerHTML') if(node.hasAttribute('@click'))&#123; let attrVal = node.getAttribute('@click') node.removeAttribute('@click') node.addEventListener('click',e =&gt; &#123; this.methods[attrVal] &amp;&amp; this.methods[attrVal].bind(this)() &#125;) &#125; &#125; &#125; &#125;, compileText(node,type)&#123; let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g, txt = node.textContent; if(reg.test(txt))&#123; node.textContent = txt.replace(reg,(matched,value)=&gt;&#123; let tpl = this.watcherTask[value] || [] tpl.push(new Watcher(node,this,value,type)) if(value.split('.').length &gt; 1)&#123; let v = null value.split('.').forEach((val,i)=&gt;&#123; v = !v ? this[val] : v[val] &#125;) return v &#125;else&#123; return this[value] &#125; &#125;) &#125; &#125; &#125; 这里代码比较多，我们拆分看你就会觉得很简单了 首先我们先遍历el元素下面的所有子节点，node.nodeType === 3 的意思是当前元素是文本节点，node.nodeType === 1 的意思是当前元素是元素节点。因为可能有的是纯文本的形式，如纯双花括号就是纯文本的文本节点，然后通过判断元素节点是否还存在子节点，如果有的话就递归调用compile方法。下面重头戏来了，我们拆开看：12345if(node.hasAttribute('v-html'))&#123; let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'innerHTML')) node.removeAttribute('v-html')&#125; 上面这个首先判断node节点上是否有v-html这种指令，如果存在的话，我们就发布订阅，怎么发布订阅呢？只需要把当前需要订阅的数据push到watcherTask里面，然后到时候在设置值的时候就可以批量更新了，实现双向数据绑定，也就是下面的操作123that.watcherTask[key].forEach(task =&gt; &#123; task.update()&#125;) 然后push的值是一个Watcher的实例，首先他new的时候会先执行一次，执行的操作就是去把纯双花括号 -&gt; 1，也就是说把我们写好的模板数据更新到模板视图上。最后把当前元素属性剔除出去，我们用Vue的时候也是看不到这种指令的，不剔除也不影响 至于Watcher是什么，看下面就知道了 Watcher123456789101112class Watcher&#123; constructor(el,vm,value,type)&#123; this.el = el; this.vm = vm; this.value = value; this.type = type; this.update() &#125; update()&#123; this.el[this.type] = this.vm.data[this.value] &#125;&#125; 之前发布订阅之后走了这里面的操作，意思就是把当前元素如：node.innerHTML = ‘这是data里面的值’、node.value = ‘这个是表单的数据’ 那么我们为什么不直接去更新呢，还需要update做什么，不是多此一举吗？其实update记得吗？我们在订阅池里面需要批量更新，就是通过调用Watcher原型上的update方法。 效果在线效果地址，大家可以浏览器看一下效果，由于本人太懒了，gif效果图就先不放了，哈哈😄😄 完整代码完整代码已经放到github上了 -&gt; MyVue 参考剖析Vue原理&amp;实现双向绑定MVVM仿Vue实现极简双向绑定 QQ群有兴趣的同学可以加qq群: 725165362 点击加入]]></content>
      <categories>
        <category>javascript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之Web Worker]]></title>
    <url>%2F2018%2F09%2F10%2FJavaScript%E4%B9%8BWeb-Worker%2F</url>
    <content type="text"><![CDATA[介绍 Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O (尽管responseXML和channel属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。 Web Worker使用要点 同源限制：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 DOM 限制：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。 通信联系：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 脚本限制：Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。 文件限制：Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。后面我们允许会做处理。 安装http-serverWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。所以我们得起一个项目。使用http-server最简单安装：1&gt; cnpm i -g http-server 使用：1&gt; http-server 基本使用我们新建一个文件夹名叫worker，里面新建三个文件分别是123index.htmlmain.jsworker.js 新建一个worker线程很简单，只需： 1var worker = new Worker(&apos;worker.js&apos;) main.js:12345678910var worker = new Worker('./worker.js')console.log('worker running')worker.addEventListener('message',e =&gt; &#123; console.log('main: ', e.data);&#125;)// 也可使用：// worker.onmessage = (e)=&gt;&#123;// console.log('main: ', e.data);// &#125;worker.postMessage('hello worker,I am from main.js') worker.js:123456console.log('worker task running')onmessage = (e)=&gt;&#123; console.log('worker task receive', e.data); // 发送数据事件 postMessage('Hello, I am from Worker.js');&#125; 在worker文件夹下，命令行输入http-server,启动项目，用浏览器打开，看控制台：1234worker runningworker task runningworker task receive hello worker,I am from main.jsmain: Hello, I am from Worker.js 从上面可以看到，worker通过onmessage来监听数据，通过postMessgae来发送数据 终止 worker1worker.terminate(); 处理错误123worker.addEventListener(&apos;error&apos;, (e) =&gt; &#123; console.log(&apos;main error&apos;, &apos;filename:&apos; + e.filename + &apos;message:&apos; + e.message + &apos;lineno:&apos; + e.lineno;&#125;); event.filename: 导致错误的 Worker 脚本的名称； event.message: 错误的信息； event.lineno: 出现错误的行号； 加载外部脚本main.js1var worker = new Worker('./worker1.js'); worker1.js12345console.log("I'm worker1")importScripts('worker2.js', 'worker3.js');// 或者// importScripts('worker2.js');// importScripts('worker3.js'); worker2.js1console.log("I'm worker2") worker3.js1console.log("I'm worker3") 兼容性https://caniuse.com/#feat=webworkers兼容性还不是很乐观，不过在移动端的兼容性还不错 参考使用 Web WorkersWeb Worker 使用教程]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之实现一个简单的promise]]></title>
    <url>%2F2018%2F09%2F09%2FJavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%2F</url>
    <content type="text"><![CDATA[我们在开发过程中大多会用到promise，想必大家对promise的使用都很熟练了，今天我们就来实现一个简单的promise，实现的效果如有出入还往指正。 整体结构我们先来梳理一下整体的结果，以便后续好操作 1234567891011121314151617class MyPromise &#123; constructor(fn)&#123; &#125; resolve()&#123; &#125; then()&#123; &#125; reject()&#123; &#125; catch()&#123; &#125;&#125; Promise理论知识 摘抄至 http://es6.ruanyifeng.com/#docs/promise#Promise-all Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 总结一下就是promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），还有就是状态的改变只能是pending -&gt; fulfilled 或者 pending -&gt; rejected，这些很重要 实现构造函数现在我们开始实现构造函数 1234567891011class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; ...&#125; 构造函数接收一个参数fn，且这个参数必须是一个函数，因为我们一般这样使用new Promise((resolve,reject)=&gt;{});然后初始化一下promise的状态，默认开始为pending，初始化value的值。fn接收两个参数，resolve、reject resolve12345678910111213141516class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; ...&#125; 当resolve执行，接收到一个值之后；状态就由 pending -&gt; fulfilled；当前的值为接收的值 reject1234567891011121314151617181920class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; reject(reason)&#123; if(this.state !== 'pending') return; this.state = 'rejected'; this.value = reason &#125;&#125; 当reject执行，接收到一个值之后；状态就由 pending -&gt; rejected；当前的值为接收的值 then1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; reject(reason)&#123; if(this.state !== 'pending') return; this.state = 'rejected'; this.value = reason &#125; then(fulfilled,rejected)&#123; if (typeof fulfilled !== 'function' &amp;&amp; typeof rejected !== 'function' ) &#123; return this; &#125; if (typeof fulfilled !== 'function' &amp;&amp; this.state === 'fulfilled' || typeof rejected !== 'function' &amp;&amp; this.state === 'rejected') &#123; return this; &#125; return new MyPromise((resolve,reject)=&gt;&#123; if(fulfilled &amp;&amp; typeof fulfilled === 'function' &amp;&amp; this.state === 'fulfilled')&#123; let result = fulfilled(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; if(rejected &amp;&amp; typeof rejected === 'function' &amp;&amp; this.state === 'rejected')&#123; let result = rejected(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; &#125;) &#125;&#125; then的实现比较关键，首先有两个判断，第一个判断传的两个参数是否都是函数，如果部不是return this执行下一步操作。第二个判断的作用是，比如，现在状态从pending -&gt; rejected;但是中间代码中有许多个.then的操作，我们需要跳过这些操作执行.catch的代码。如下面的代码，执行结果只会打印1123456789new Promise((resolve,reject)=&gt;&#123; reject(1)&#125;).then(()=&gt;&#123; console.log(2)&#125;).then(()=&gt;&#123; console.log(3)&#125;).catch((e)=&gt;&#123; console.log(e)&#125;) 我们继续，接下来看到的是返回了一个新的promise，真正then的实现的确都是返回一个promise实例。这里不多说 下面有两个判断，作用是判断是rejected还是fulfilled,首先看fulfilled，如果是fulfilled的话，首先执行fulfilled函数，并把当前的value值传过去，也就是下面这步操作,res就是传过去的value值，并执行了(res)=&gt;{console.log(res)}这段代码;执行完成之后我们得到了result；也就是2这个结果，下面就是判断当前结果是否是一个promise实例了，也就是下面注释了的情况，现在我们直接执行resolve(result);1234567new Promise((resolve,reject)=&gt;&#123; resolve(1)&#125;).then((res)=&gt;&#123; console.log(res) return 2 //return new Promise(resolve=&gt;&#123;&#125;)&#125;) 剩下的就不多说了，可以debugger看看执行结果 catch123456class MyPromise &#123; ... catch(rejected)&#123; return this.then(null,rejected) &#125;&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; reject(reason)&#123; if(this.state !== 'pending') return; this.state = 'rejected'; this.value = reason &#125; then(fulfilled,rejected)&#123; if (typeof fulfilled !== 'function' &amp;&amp; typeof rejected !== 'function' ) &#123; return this; &#125; if (typeof fulfilled !== 'function' &amp;&amp; this.state === 'fulfilled' || typeof rejected !== 'function' &amp;&amp; this.state === 'rejected') &#123; return this; &#125; return new MyPromise((resolve,reject)=&gt;&#123; if(fulfilled &amp;&amp; typeof fulfilled === 'function' &amp;&amp; this.state === 'fulfilled')&#123; let result = fulfilled(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; if(rejected &amp;&amp; typeof rejected === 'function' &amp;&amp; this.state === 'rejected')&#123; let result = rejected(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; &#125;) &#125; catch(rejected)&#123; return this.then(null,rejected) &#125;&#125; 测试123456789101112131415161718192021222324new MyPromise((resolve,reject)=&gt;&#123; console.log(1); //reject(2) resolve(2) console.log(3) setTimeout(()=&gt;&#123;console.log(4)&#125;,0)&#125;).then(res=&gt;&#123; console.log(res) return new MyPromise((resolve,reject)=&gt;&#123; resolve(5) &#125;).then(res=&gt;&#123; return res &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;).catch(e=&gt;&#123; console.log('e',e)&#125;)执行结果：&gt; 1&gt; 3&gt; 2&gt; 5&gt; 4 原生promise123456789101112131415161718192021222324new Promise((resolve,reject)=&gt;&#123; console.log(1); //reject(2) resolve(2) console.log(3) setTimeout(()=&gt;&#123;console.log(4)&#125;,0)&#125;).then(res=&gt;&#123; console.log(res) return new Promise((resolve,reject)=&gt;&#123; resolve(5) &#125;).then(res=&gt;&#123; return res &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;).catch(e=&gt;&#123; console.log('e',e)&#125;)执行结果：&gt; 1&gt; 3&gt; 2&gt; 5&gt; 4]]></content>
      <categories>
        <category>javascript</category>
        <category>promise</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript之浅拷贝与深拷贝]]></title>
    <url>%2F2018%2F07%2F29%2FJavsScript%E4%B9%8B%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在开发的过程中，我们往往需要复制一个数据，在复制基本数据类型的时候不会出现问题，如string、number、null等。但是我们复制一个引用类型的数据时，往往会出现问题，如array、object。 浅拷贝看下面这段代码123var arr1 = [1,2,3];var arr2 = arr1;arr2.push(4) 我们打印一下看看arr1 arr2的结果12arr1: [1, 2, 3, 4]arr2: [1, 2, 3, 4] 我们发现，改变arr2的同时也改变了arr1，WTF？ 接下来我们看看对象12345var obj1 = &#123; name:'wclimb' &#125;;var obj2 = obj1obj2.age = 24 我们打印一下看看arr1`arr2`的结果12obj1: &#123;name: "wclimb", age: 24&#125;obj2: &#123;name: "wclimb", age: 24&#125; 和预想的一样，都被影响了。why?因为引用类型的复制，两个引用类型的指针都指向同一个堆内存 网上偶尔会看到有人说slice、concat是深拷贝，其实这两个是浅复制，如下123var arr1 = [1,2,3];var arr2 = arr1.slice();arr2.push(4) 结果：12arr1 [1, 2, 3]arr2 [1, 2, 3, 4] 数组元素只是基本数据类型不会有影响，那么我们看下面的123var arr1 = [1,2,3,[4]];var arr2 = arr1.slice();arr2[3].push(5) 结果12arr1: [1,2,3,[4,5]] &lt;----- 被影响了arr2: [1,2,3,[4,5]] 即使使用了slice, 两个数组也相互影响了，类似方法除了slice、concat还有Array.from、... 深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的拷贝实体，而不是引用 深拷贝Object.assignObject.assign可以进行一层的深度拷贝，也就是跟slice类型的效果1234567891011121314151617181920212223242526var obj1 = &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.age = 24结果：obj1: &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;obj2: &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125;, age: 24 &#125;; 但是我们看下面的例子12345678910111213141516171819202122232425262728var obj1 = &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.age = 24obj2.test4.val = '1';结果： obj1: &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;val: 1&#125; &lt;----- 被影响了 &#125;;obj2: &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;val: 1&#125;, age: 24 &#125;; JSON.parse(JSON.stringify(obj))说到深拷贝，你一定会想到JSON.parse(JSON.stringify(obj));没错，这样可以完成一个深拷贝，看下面的例子： 12345var obj1 = &#123; name: 'wclimb' &#125;;var obj2 = JSON.parse(JSON.stringify(obj1))obj2.age = 24 结果12obj1: &#123;name: "wclimb"&#125; &lt;----- 没有被影响了obj2: &#123;name: "wclimb", age: 24&#125; perfect，但是这个方法会有一个问题，如下例：123456789var var obj1 = &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj1))obj2.age = 24 结果12345678910111213obj1: &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;obj2: &#123; name: "wclimb", age: 24, test1: null, test4: &#123;&#125; &#125; WTF，那两个个跑哪去了？所以这个方法不能够拷贝值为undefined、function 深拷贝实现那么怎么进行深拷贝呢？我的方法是：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function deepCopy(obj)&#123; var result; var toString = Object.prototype.toString if(toString.call(obj) === '[object Array]')&#123; result = [] for(var i = 0 ;i &lt; obj.length; i++)&#123; result[i] = deepCopy(obj[i]) &#125; &#125;else if(toString.call(obj) === '[object Object]')&#123; result = &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = deepCopy(obj[key]) &#125; &#125; &#125;else&#123; return obj &#125; return result&#125;测试一下：var obj1 = &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = deepCopy(obj1)obj2.age = 24obj2.test4.val = '1';返回： obj1: &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &lt;----- 没有被影响了 &#125;;obj2: &#123; age: 24, name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;val: '1'&#125; &#125;; jQuery的实现123456789var obj1 = &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = $.extend(true, &#123;&#125;, obj1)obj2.age = 24 lodash的实现123456789var obj1 = &#123; name: 'wclimb', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = _.cloneDeep(obj1)obj2.age = 24 GitHub：wclimb 个人小程序]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node项目服务器部署(新手教程)]]></title>
    <url>%2F2018%2F07%2F28%2Fnode%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[写在前面之前在github写了几个项目，然后一直有很多人问我node项目怎么部署到服务器上，于是乎应大家要求就写了这篇文章，此篇教程只提供给新手借鉴，如果你是大佬的话可以不用往下看了，教程多少有些缺陷，都是按照自己的印象写出来的，所以有问题还望指正。 linux服务器安装node首先下载node包1wget https://npm.taobao.org/mirrors/node/latest-v8.x/node-v8.1.0-linux-x64.tar.gz 解压1tar xvf node-v8.1.0-linux-x64.tar.gz 12ln -s ~/node-v8.1.0-linux-x64/bin/node /usr/local/bin/nodeln -s ~/node-v8.1.0-linux-x64/bin/npm /usr/local/bin/npm 最后node -v查看node版本，如果出现以下就表示安装成功了1v8.1.0 如果你需要升级node版本，执行以下命令即可12sudo npm i -g nn stable 安装pm2pm2是一个进程守护工具,类似的还有forever 1sudo npm i pm2 -g 然后执行，如果不映射的话，会出现pm2不是内部指令的错误1ln -s ~/node-v8.1.0-linux-x64/bin/pm2 /usr/local/bin/pm2 我们顺便把git和cnpm也安装了123yum install gitsudo npm i -g cnpmln -s ~/node-v8.1.0-linux-x64/bin/cnpm /usr/bin/cnpm 安装mysql卸载已有的mysql12rpm -qa|grep -i mysqlyum remove &apos;mysql&apos; 下载mysql的repo源12wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpmrpm -ivh mysql57-community-release-el7-7.noarch.rpm 安装123yum install mysql-serveryum install mysql-develyum install mysql 然后查看刚刚安装的mysql1rpm -qa|grep -i mysql 登录1234service mysqld status 查看mysql当前的状态service mysqld stop 停止mysqlservice mysqld restart 重启mysqlservice mysqld start 启动mysql 在完成上述步骤之后登陆时可能遇到ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)错误。 这个错误的原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户。 12chown -R openscanner:openscanner /var/lib/mysqlchown -R root:root /var/lib/mysql 于是乎接下来就是查看一下/var/lib/mysql/mysql.sock文件是否存在，第一次查看时该文件不存在，后来在/etc/my.cnf文件中添加了user=mysql然后尝试登录1mysql -u root 会出现ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: NO) 登录root帐号需要密码，现在我们没有设置密码，哪来的密码。于是乎我们开始忘记密码的操作第一步，在/etc/my.cnf文件中添加skip-grant-tables第二步，重启mysql，service mysqld restart第三步，登录mysql，mysql -u root第四步，修改密码：1234mysql&gt;use mysql;mysql&gt;update mysql.user set authentication_string=password(&apos;你的密码&apos;) where user=&apos;root&apos;;mysql&gt;flush privileges;mysql&gt;exit; 第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉第六步，重启mysql，service mysqld restart 分配用户 host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录; 12CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;CREATE USER &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;; 给创建的用户权限 privileges：用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL;databasename：数据库名。tablename：表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*. 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; 下面表示给test用户所有数据库和表的权限 mysql&gt;GRANT ALL ON . TO ‘test‘@’%’; 安装nginx安装1yum -y install nginx 启动1service nginx start 查找nginx安装在哪，我这里是/etc/nginx/conf.d1whereis nginx 进入文件夹1cd /etc/nginx/conf.d 然后新建文件，这里以我的域名为例1vi www.wclimb.site.conf 然后里面的文件内容我们先不写，我们先把node项目部署一下 使用pm2启动node项目这里以我的项目为例koa2-blog我们先找到合适的文件夹存放我们得项目，然后git clone一下（git我们之前安装过了） 该项目的数据库名叫nodeSql，使用运行之前得先建立好数据库，然后再运行项目，登录数据库执行 create database nodesql; 1234git clone https://github.com/wclimb/Koa2-blog.gitcd Koa2-blogcnpm i pm2 start index.js 上面pm2我们也安装过，该项目监听的是3000端口，项目已经运行起来了可以使用pm2 list查看进程列表，使用pm2 log打印日志 nginx配置记得刚刚我们没有编写www.wclimb.site.conf文件现在开始写入以下内容，blog.wclimb.site是我的域名，你可以在你的服务器平台去解析一下，目前我们监听的是3000端口，所以代理到30001234567server &#123; listen 80; server_name blog.wclimb.site; location / &#123; proxy_pass http://127.0.0.1:3000; &#125;&#125; 检验nginx是否正确配置1nginx -t 重启nginx1service nginx restart 如果不成功，可能还需执行一下命令12systemctl stop httpdsystemctl disable httpd 完结OK，现在访问域名看看是否有效果了，整个流程可能有写纰漏，大致流程也差不多了，希望对你有帮助 GitHub：wclimb 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之函数记忆]]></title>
    <url>%2F2018%2F07%2F12%2FJavaScript%E4%B9%8B%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BF%86%2F</url>
    <content type="text"><![CDATA[最近在读语言精粹，读到函数记忆这块，觉得有必要记录一下 我们在开发过程中经常使用递归的方式调用函数，但是开发过程中很少有关心性能问题 我们看一下下面这段代码123456789var count = 0var f = function(n)&#123; count++ return n &lt; 2 ? n : f(n - 1) + f(n - 2);&#125;for(var i = 0; i &lt;= 10; i++)&#123; console.log(i,f(i))&#125;console.log('执行次数', count) 结果1234567891011120 01 12 13 24 35 56 87 138 219 3410 55'执行次数', 453 执行一遍发现，f这个函数被调用了453次，我们调用了11次，而它自身调用了442次去计算可能已经被刚计算过的值。如果我们让函数具备记忆功能，就可以显著减少运算量。 接下来，我们定义一个memo的数组来保存我们得储存结果，并把它隐藏在闭包中，让该函数能一直访问到这个数组，不被垃圾回收机制回收 123456789101112131415161718var count = 0var f = function()&#123; var memo = [0,1]; var fib = function(n)&#123; count++ var result = memo[n]; if(typeof result !== 'number')&#123; result = fib(n - 1) + fib(n - 2) memo[n] = result &#125; return result &#125; return fib&#125;()for(var i = 0; i &lt;= 10; i++)&#123; console.log(i,f(i))&#125;console.log('执行次数', count) 执行结果1234567891011120 01 12 13 24 35 56 87 138 219 3410 55执行次数 29 现在f函数只被调用了29次，我们调用了它11次，它调用了18次去取得之前储存的结果。 先就分享到这吧，关键拓宽思路 GitHub：wclimb]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之原型与原型链]]></title>
    <url>%2F2018%2F06%2F13%2FJavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[万物皆对象在JavaScript中除值类型之外，其他的都是对象，为了说明这点，我们举几个例子我们可以使用typeof来做类型判断 123456789typeof a; // undefinedtypeof 1; // numbertypeof 'wclimb'; // stringtypeof true; // booleantypeof function()&#123;&#125;; // functiontypeof []; // objecttypeof null; // objecttypeof &#123;&#125;; // object 除了undefined、number、string、boolean属于值类型之外，其他都是对象。你可能要问了，不是还有一个是function吗？要校验他是不是应该对象可以这样做:12var fn = function()&#123;&#125;fn instanceof Object // true 由上面的例子所示，函数确实是对象，为什么呢？我们看一下下面的例子12345function Person(name)&#123; this.name = name; &#125;var person = new Person('wclimb');console.log(person) // Person &#123;name: "wclimb"&#125; 由此我们可以得知，对象都是通过函数创建的，这么说你可能又会说不对，你看下面的就不是函数创建的1var person = &#123;name:'wclimb'&#125; 你咋就这么飘呢？我竟无言以对，没错，这是个意外、意外、意外。但是归根结底他还是通过函数创建的12var person = new Object()person.name = 'wclimb' so，现在你只要知道对象是通过函数创建的就可以了，来跟着我读：第一遍 对象都是通过函数创建的第二遍 对象都是通过函数创建的第三遍 对象都是通过函数创建的 构造函数(constructor)12345function Person(name)&#123; this.name = name&#125;var person1 = new Person('wclimb 1')var person2 = new Person('wclimb 2') 上面Person就是一个构造函数，我们通过new的方式创建了一个实例对象person我们来看看person1和person2的constructor(构造函数)是不是指向Person的12person1.constructor === Person // trueperson2.constructor === Person // true 原型(prototype)在JavaScript中，每定义一个函数都会产生一个prototype(原型)属性，这个属性指向函数的原型对象12345678function Person()&#123;&#125;Person.prototype.name = 'wclimb'Person.prototype.age = '24'Person.prototype.sayAge = function()&#123; console.log(this.age)&#125;var person = new Person()person.sayAge(); // 24 那么这个prototype到底是什么呢？跟构造函数有关系吗？ 上图就可以反映出他们之间的关系 其实函数的prototype指向函数的原型对象，每个对象都会关联另外一个对象，也就是原型，上面的例子改成：1234567Person.prototype = &#123; name: 'wclimb', age: 24, satAge: function()&#123; console.log(this.age) &#125;&#125; 隐式原型(__proto__)上面我们说到每定义一个函数都会产生一个原型，每个函数它不止有原型，还有一个__proto__(隐式原型)每个对象都有一个__proto__属性，指向创建该对象函数的prototype，我们可以来试试，还是上面的例子：123function Person()&#123;&#125;var person = new Person()person.__proto__ === Person.prototype // true 现在他们的关系图如下 由上图我们可以知道：123Person.prototype.constructor = Personperson.__proto__ = Person.prototypeperson.constructor = Person 我们可以看到person.__proto__指向构造函数的原型，那么构造函数的原型即Person的__proto__指向哪里呢？我们知道构造函数其实就是由Function来创建的，由此得出:1Person.__proto__ === Function.prototype 那么构造函数的原型即Person.prototype的__proto__指向哪里呢？原型对象其实是通过Object生成的，自然而然的得出:1Person.prototype.__proto__ === Object.prototype 那么Object.prototype的__proto__指向哪里呢？答案是null，最终得到下面的图 抛开这张图，来看看下面几道题 person.__proto__ Person.__proto__ Person.prototype.__proto__ Object.__proto__ Object.prototype.__proto__ 解： 每个对象都有一个__proto__属性，指向创建该对象函数的prototype，因为Person是person的构造函数Person === person.constructor为true,所以：person.__proto__ === Person.prototype Person构造函数是由Function创建的，所以可以得出Person.__proto__ === Fucntion.prototype 我们上面说过Person.prototype其实是一个对象，而对象是由Object创建的，所以 Person.prototype.__proto__ === Object.prototype Object对象都是函数创建的，所以Object.__proto__ === Function.prototype 虽然Object.prototype是一个对象但是他的__proto__为null 实例和原型当我们要取一个值的时候，会先从实例中取，如果实例中存在，则取实例的值，如果实例不存在，则会顺着原型里找，直到找到 12345678function Person()&#123;&#125;Person.prototype.name = '我来自原型'var person = new Person()person.name = '我来自实例'console.log(person.name); // 我来自实例delete person.nameconsole.log(person.name)); // 我来自原型 首先person实例中有这个属性，返回我来自实例,然后将它删除之后，会从原型中招，也就是person.__proto__，因为Person.prototype === person.__proto__，所以得到我来自原型 总结原型和原型链基本已经讲解完，不过还有待完善，如有错误，还望指正 GitHub：wclimb 个人小程序 QQ群有兴趣的同学可以加qq群: 725165362 点击加入]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之节流与防抖]]></title>
    <url>%2F2018%2F06%2F12%2FJavaScript%E4%B9%8B%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[背景我们在开发的过程中会经常使用如scroll、resize、touchmove等事件，如果正常绑定事件处理函数的话，有可能在很短的时间内多次连续触发事件，十分影响性能。因此针对这类事件要进行节流或者防抖处理 节流节流的意思是，在规定的时间内只会触发一次函数，如我们设置函数500ms触发一次，之后你无论你触发了多少次函数，在这个时间内也只会有一次执行效果 先来看一个例子 See the Pen gKWLpO by wclimb (@wclimb) on CodePen. 我们看到使用了节流的在1000ms内只触发了一次，而没有使用节流的则频繁触发了调用的函数 接下来看看代码实现v1 第一次不触发，不传参实现12345678910111213function throttle(fn,interval)&#123; var timer; return function()&#123; if(timer)&#123; return &#125; timer = setTimeout(() =&gt; &#123; clearTimeout(timer) timer = null fn() &#125;, interval || 1000); &#125; &#125; 效果是实现了，但是我在尝试在执行函数里console.log(this)，结果发现this指向的是window，而且还发现我们不能传递参数，下面就来改进一下v2 第一次触发函数，接收参数1234567891011121314151617181920function throttle(fn,interval)&#123; var timer, isFirst = true; return function()&#123; var args = arguments, that = this; if(isFirst)&#123; fn.apply(that,args) return isFirst = false &#125; if(timer)&#123; return &#125; timer = setTimeout(() =&gt; &#123; clearTimeout(timer) timer = null fn.apply(that,args) &#125;, interval || 1000); &#125; &#125; 防抖防抖的意思是无论你触发多少次函数，只会触发最后一次函数。最常用的就是在表单提交的时候，用户可能会一段时间内点击很多次，这个时候可以增加防抖处理，我们只需要最后一次触发的事件 先来看一个例子 See the Pen pKPeyv by wclimb (@wclimb) on CodePen. 我们看到使用了防抖的方框，无论你在里面触发了多少次函数，都只会触发最后的那一次函数，而没有使用防抖的则频繁触发了调用的函数 v1 第一次不触发函数 1234567891011121314function debounce(fn,interval)&#123; var timer; return function()&#123; var args = arguments, that = this; if(timer)&#123; clearTimeout(timer) timer = null &#125; timer = setTimeout(() =&gt; &#123; fn.apply(null,args) &#125;, interval || 1000); &#125;&#125; 上面这段代码仍然可以正常执行，但是我们并没有指定他的this v2 第一次就触发函数123456789101112131415161718192021222324function debounce(fn,interval)&#123; var timer, isFirst = true, can = false; return function()&#123; var args = arguments, that = this; if(timer)&#123; clearTimeout(timer) timer = null &#125; if(isFirst)&#123; fn.apply(that,args) isFirst = false setTimeout(() =&gt; &#123; can = true &#125;, interval || 1000); &#125;else if(can)&#123; timer = setTimeout(() =&gt; &#123; fn.apply(null,args) &#125;, interval || 1000); &#125; &#125;&#125; 如有雷同，纯属抄我（开玩笑） 如有错误，还望指正，仅供参考 GitHub：wclimb QQ群有兴趣的同学可以加qq群: 725165362 点击加入 个人小程序]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP缓存——304与200 from cache]]></title>
    <url>%2F2018%2F03%2F06%2FHTTP%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94304%E4%B8%8E200-from-cache%2F</url>
    <content type="text"><![CDATA[HTTP与缓存相关的字段1. 通用字段 字段名称 释义 Cache-Control 控制缓存具体的行为 Pragma HTTP1.0时的遗留字段，当值为”no-cache”时强制验证缓存 Date 创建报文的日期时间(启发式缓存阶段所用) 2. response字段 字段名称 释义 ETag 服务器生成资源的唯一标识 Vary 代理服务器缓存的管理信息 Age 资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小) 3. request字段 字段名称 释义 If-Match 条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改 If-None-Match 和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改 If-Modified-Since 比较资源前后两次访问最后的修改时间是否一致 If-Unmodified-Since 比较资源前后两次访问最后的修改时间是否一致 4. 实体字段 字段名称 释义 Expires 告知客户端资源缓存失效的绝对时间 Last-Modified 资源最后一次修改的时间 协商缓存（304） If-modified-Since/Last-Modified 浏览器在发送请求的时候服务器会检查请求头request header里面的If-modified-Since，如果最后修改时间相同则返回304，否则给返回头(response header)添加last-Modified并且返回数据(response body)。12if-modified-since:Wed, 31 May 2017 03:21:09 GMTif-none-match:&quot;42DD5684635105372FE7720E3B39B96A&quot; If-None-Match/Etag 浏览器在发送请求的时候服务器会检查请求头(request header)里面的if-none-match的值与当前文件的内容通过hash算法（例如 nodejs: cryto.createHash(&#39;sha1&#39;)）生成的内容摘要字符对比，相同则直接返回304，否则给返回头(response header)添加etag属性为当前的内容摘要字符，并且返回内容。12etag:&quot;42DD5684635105372FE7720E3B39B96A&quot;last-modified:Wed, 31 May 2017 03:21:09 GMT 请求头last-modified的日期与响应头的last-modified一致请求头if-none-match的hash与响应头的etag一致所用会返回Status Code: 304 强缓存（200 from cache） 如果设置了Expires(XX时间过期)或者Cache-Control（http1.0不支持）(经历XX时间后过期)且没有过期，命中cache的情况下，from cache不去发出请求。如果强刷（如ctrl+r）会发起请求，但是如果没有修改会返回304内容未修改，如果已经改变则返回新内容。max-age &gt; Expires。 expires/cache-control虽然是强缓存，但用户主动触发的刷新行为，还是会采用缓存协商的策略，主动触发的刷新行为包括点击刷新按钮、右键刷新、f5刷新、ctrl+f5刷新等。 当然如果在控制台里面选中了disable cahce则无论如何都会请求最新内容(304协商缓存、强缓存都无效)，因为1.不会检查本地是否有缓存。2.请求头信息(request header)既没有If-Modified-Since也没有If-None-Match来让服务端判断。地址栏输入的地址按下回车键，该地址页面请求（仅仅是该url）的request header都会带上cache-contro:max-age=0，所以不会命中强缓存，但是通过链接点击的地址会命中缓存 chrome下查看所有的from cache文件：chrome://view-http-cache/ 区别 触发 200 from cache： 直接点击链接访问 输入网址按回车访问 二维码扫描 触发 304： 刷新页面时触发 设置了长缓存、但Entity Tags没有移除时触发 流程图 GitHub：wclimb 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>缓存</tag>
        <tag>Mysql</tag>
        <tag>javascript</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs微信支付之扫码支付]]></title>
    <url>%2F2018%2F02%2F14%2Fnodejs%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E4%B9%8B%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要是记录本人在微信扫码支付过程中所遇到的问题，给大家一个借鉴作用，希望对你们有帮助 开发环境 nodejs v8.1.0 egg v1.1.0 准备工作 微信公众号-appid 微信商户号-mch_id key值(签名算法所需,其实就是一个32位的密码，可以用md5生成一个)(key设置路径：微信商户平台(pay.weixin.qq.com)–&gt;账户设置–&gt;API安全–&gt;密钥设置) 扫码支付-统一下单以下才用的是微信模式二，因为比较简单123456789101112131415 let MD5 = require('md5'), xml2js = require('xml2js'), url = "https://api.mch.weixin.qq.com/pay/unifiedorder",// 下单请求地址 appid = '公众号id', mch_id = '微信商户号'； notify_url = '回调地址', out_trade_no = '自己设置的订单号',// 微信会有自己订单号、我们自己的系统需要设置自己的订单号 total_fee = '订单金额',// 注意，单位为分 body = '商品简单描述', trade_type = 'NATIVE',// 交易类型，JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付 nonce_str = moment().format('YYYYMMDDHHmmssSSS'),// 随机字符串32位以下 stringA = `appid=$&#123;公众号id&#125;&amp;body=$&#123;body&#125;&amp;mch_id=$&#123;微信商户号&#125;&amp;nonce_str=$&#123;nonce_str&#125;&amp;notify_url=$&#123;notify_url&#125;&amp;out_trade_no=$&#123;out_trade_no&#125;&amp;spbill_create_ip=$&#123;ctx.request.ip&#125;&amp;total_fee=$&#123;total_fee&#125;&amp;trade_type=$&#123;trade_type&#125;`, stringSignTemp = stringA + "&amp;key=xxxxxxxxxxxxxxxxx", //注：key为商户平台设置的密钥key sign = MD5(stringSignTemp).toUpperCase(); //注：MD5签名方式 以上就是我们所需要的一些参数签名生成算法见微信官方spbill_create_ip 是 终端ip地址 下面把所有的参数拼接成xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 const formData = "&lt;xml&gt;"; formData += "&lt;appid&gt;" + appid + "&lt;/appid&gt;"; //appid formData += "&lt;body&gt;" + body + "&lt;/body&gt;"; //商品或支付单简要描述 formData += "&lt;mch_id&gt;" + mch_id + "&lt;/mch_id&gt;"; //商户号 formData += "&lt;nonce_str&gt;" + nonce_str + "&lt;/nonce_str&gt;"; //随机字符串，不长于32位 formData += "&lt;notify_url&gt;" + notify_url + "&lt;/notify_url&gt;"; //支付成功后微信服务器通过POST请求通知这个地址 formData += "&lt;out_trade_no&gt;" + out_trade_no + "&lt;/out_trade_no&gt;"; //订单号 formData += "&lt;total_fee&gt;" + total_fee + "&lt;/total_fee&gt;"; //金额 formData += "&lt;spbill_create_ip&gt;" + ctx.request.ip + "&lt;/spbill_create_ip&gt;"; //ip formData += "&lt;trade_type&gt;NATIVE&lt;/trade_type&gt;"; //NATIVE会返回code_url ，JSAPI不会返回 formData += "&lt;sign&gt;" + sign + "&lt;/sign&gt;"; formData += "&lt;/xml&gt;"; // 这里使用了egg里面请求的方式const resultData = yield ctx.curl(url, &#123; method: 'POST', content: formData, headers: &#123; 'content-type': 'text/html', &#125;, &#125;);// xml转json格式xml2js.parseString(resultData.data, function (err, json) &#123; if (err) &#123; new Error("解析xml报错") &#125; else &#123; var result = formMessage(json.xml); // 转换成正常的json 数据 console.log(result) //打印出返回的结果 &#125;&#125;) var formMessage = function (result) &#123; var message = &#123;&#125;; if (typeof result === 'object') &#123; var keys = Object.keys(result); for (var i = 0; i &lt; keys.length; i++) &#123; var item = result[keys[i]]; var key = keys[i]; if (!(item instanceof Array) || item.length === 0) &#123; continue; &#125; if (item.length === 1) &#123; var val = item[0]; if (typeof val === 'object') &#123; message[key] = formMessage(val); &#125; else &#123; message[key] = (val || '').trim(); &#125; &#125; else &#123; message[key] = []; for (var j = 0, k = item.length; j &lt; k; j++) &#123; message[key].push(formMessage(itemp[j])); &#125; &#125; &#125; &#125; return message; &#125; 上面使用了egg的请求方式，node可以使用request123456789var request = require('request');request(&#123; url: url, method: "POST", body: formData&#125;, function(error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; &#125;&#125;); 如果请求成功会最终返回一个xml,然后我们进行解析成json的格式,里面会有一个code_url和out_trade_no,我们需要把这两个返回给前端，然后通过生成二维码展示给用户扫码，完成支付 监听支付是否成功上面操作完成之后，我们需要知道用户是否完成支付，因为用户会停留在该页面，我们需要在用户付完款之后，通知用户支付成功。首先，用户发起支付的时候我们会生成二维码，让用户完成扫码支付，我们还要做的是，开一个定时器，每隔一段时间去发送一个请求，这个时候，我们node后台就需要写一个查询订单的接口，之前我们拿到了out_trade_no，也就是我们系统内部的订单号，我们把这个数据发送给后台查询订单的接口，然后后台接收到之后会请求微信的查询接口地址https://api.mch.weixin.qq.com/pay/orderquery,流程跟上面一样，只是接口地址和微信返回的xml不一样而已，返回的字段会有一个状态即SUCCESS和NOTPAY，我们可以通过判断是否支付返回给前端，成功之后提示给用户支付成功，关闭定时器。 回调地址这个是非常重要的一环，大部分的操作其实在上面就可以完成，但是有特殊的情况，比如用户电脑断网发送不了请求，但是手机付款了，这就会导致我们记录不到用户支付的信息。这个时候回调地址就很重要了 设置回调地址微信商户中心-&gt;产品中心-&gt;开发配置-&gt;扫码支付 之后我们需要做的是后端用post来接收微信发送的异步回调信息，也是xml的格式，这里注意，如果不支持接收xml，可能会得到空的数据这里还需要注意的是，我们在保存用户支付信息的同时，得先查改订单是否支付，以免重复操作，可能会插入多条记录的情况 总结微信扫码支付坑还是有的，如果你是第一次摸索的话，下面罗列一下需要注意的地方 签名算法要写正确，不然是不会成功的，要拼接正确才行 微信返回的是xml格式的数据，我们得通过插件转成json，这样才方便获取数据 返回的code_url要给前端生成二维码用，然后需要开一个定时器查询该订单是否完成支付，最终通知用户结果 回调地址很重要，我们后端需要post接收微信返回的回调信息，然后保存信息，不过在保存用户支付信息的之前，我们得知道该订单是否已经保存过，以免重复添加。还有就是返回的是xml的数据，后端一定要保证能够接收得到，按照正常的方式是接收不了的，得额外设置。 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
        <category>微信支付</category>
        <category>egg</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>Node</tag>
        <tag>Egg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Vue2.js + Node.js 搭建一个小型的全栈项目]]></title>
    <url>%2F2017%2F09%2F08%2F%E4%BD%BF%E7%94%A8-Vue2-js-Node-js-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E7%9A%84%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[写在前面由于最近公司业务不是很忙，空闲时间比较多，于是就在纠结Vue.js（之前就学习过）和Node.js先专研哪个比较好，最终选择了先玩玩Node.js。经过一段时间的学习，就有了教程 Node+Koa2+Mysql 搭建简易博客 GitHub地址，想要了解的可以先看看，个人水平有限，希望可以帮到你。大概过来一个多月，我决定两路开工。使用Node.js给前端写接口，配备后台管理功能，先把后台搭建好。大概几天过后，后台一些简单的功能实现后，就开始用Vue.js开始搭建前台，也一直在想做点什么比较好，于是就做了个豆瓣评分类似的项目。 前端项目地址 https://github.com/wclimb/vue-video前端预览 http://video.wclimb.site 后端项目地址 https://github.com/wclimb/video-admin后台管理 http://vue.wclimb.site API接口地址 https://github.com/wclimb/video-admin/blob/master/API.md 技术栈(Vue2.js + Node.js 全栈项目) 由于页面不是很多，vuex用的不多，关键掌握怎么实现就好了 vue2 + vuex + vue-router + webpack + fetch + sass + flex + svg + 阿里字体图标 运行1234567891011git clone https://github.com/wclimb/vue-video.gitcd vue-videonpm install 建议使用淘宝镜像(https://npm.taobao.org/) =&gt; cnpm inpm run dev (运行项目)npm run build (打包项目)ps: 如果打包之后文件运行不了，请打包之前把路由的 mode:&apos;history&apos;注释掉，该功能去掉了url中丑陋的 # 号 功能 注册登录登出 + 验证码 密码检测，如果用户不存在则自动创建 检测是否登录，如果没有登录则不允许评论和评价 可以上传影片到后台，进行前台展示 评分功能，初始化评分可以自由设置，如果没有人like则默认显示原始评分，如果有则计算当前vide的评分 修改用户名，检测用户名是否跟其他人重复 上传头像，默认没有头像 评论功能，评论之后可以在个人中心展示，并且可以删除 搜索功能，可以搜索存在的影片，如果没有则显示无结果 自己喜欢的video和评论的内容会在个人中心显示 综上： [x] 注册 [x] 登录 [x] 登出 [x] 验证码 [x] 详情页 [x] 分类 [x] 分类影视列表 [x] 修改用户名 [x] 上传头像 [x] 评论 [x] 删除评论 [x] 搜索 [x] 个人中心数据 如果觉得对你有帮助还望关注一下，有问题可以即使提哟，觉得不错的话star一下也是可以的哟 前端线上地址项目是手机端的，请使用谷歌浏览器手机预览模式 首页默认一种类别只显示10个，可以查看更多显示全部 预览：vue-video 手机扫描图下二维码预览 后端线上地址技术栈：Node + Koa2 + Mysql预览：video-adminGitHub: 管理后台 前端演示 主页 登录页 个人中心页 详情页 后台演示 有问题欢迎反馈在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流 邮件(875246904#qq.com, 把#换成@) QQ: 875246904 weibo: @wclimb 目录结构12345678910111213141516171819|-- build // webpack配置文件|-- config // 项目打包路径|-- src // 源码目录| |-- assets // 图片文件| |-- base // 移动端适配| |-- components // 组件| |-- data // 接口| |-- router // 路由配置| |-- store // 状态管理| |-- style // 样式| App.vue // 页面入口文件| main.js // 程序入口文件|-- static // 静态资源|-- .babelrc // ES6语法编译配置|-- .editorconfig // 代码编写规格|-- .gitignore // git忽略的文件|-- .postcssrc.js // post-loader的插件配置文件|-- index.html // 入口html文件|-- package.json // 项目及工具的依赖配置文件 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>Node</tag>
        <tag>Koa</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础]]></title>
    <url>%2F2017%2F07%2F20%2FMySQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[转载自 mysql-tutorial 开始使用MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格： 表头(header): 每一列的名称; 列(col): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性。登录MySQL 123456mysql -h 127.0.0.1 -u 用户名 -pmysql -D 所选择的数据库名 -h 主机名 -u 用户名 -pmysql&gt; exit # 退出 使用 “quit;” 或 “\q;” 一样的效果mysql&gt; status; # 显示当前mysql的version的各种信息mysql&gt; select version(); # 显示当前mysql的version信息mysql&gt; show global variables like 'port'; # 查看MySQL端口号 创建数据库对于表的操作需要先进入库use 库名; 12345678-- 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbkcreate database samp_db character set gbk;drop database samp_db; -- 删除 库名为samp_db的库show databases; -- 显示数据库列表。use samp_db; -- 选择创建的数据库samp_dbshow tables; -- 显示samp_db下面所有的表名字describe 表名; -- 显示数据表的结构delete from 表名; -- 清空表中记录 创建数据库表 使用 create table 语句可完成对表的创建, create table 的常见形式:语法：create table 表名称(列声明); 1234567891011121314-- 如果数据库中存在user_accounts表，就把它从数据库中drop掉DROP TABLE IF EXISTS `user_accounts`;CREATE TABLE `user_accounts` ( `id` int(100) unsigned NOT NULL AUTO_INCREMENT primary key, `password` varchar(32) NOT NULL DEFAULT '' COMMENT '用户密码', `reset_password` tinyint(32) NOT NULL DEFAULT 0 COMMENT '用户类型：0－不需要重置密码；1-需要重置密码', `mobile` varchar(20) NOT NULL DEFAULT '' COMMENT '手机', `create_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `update_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), -- 创建唯一索引，不允许重复 UNIQUE INDEX idx_user_mobile(`mobile`))ENGINE=InnoDB DEFAULT CHARSET=utf8COMMENT='用户表信息'; 数据类型的属性解释 NULL：数据列可包含NULL值； NOT NULL：数据列不允许包含NULL值； DEFAULT：默认值； PRIMARY：KEY 主键； AUTO_INCREMENT：自动递增，适用于整数类型； UNSIGNED：是指数值类型只能为正数； CHARACTER SET name：指定一个字符集； COMMENT：对表或者字段说明； 增删改查SELECT SELECT 语句用于从表中选取数据。语法：SELECT 列名称 FROM 表名称语法：SELECT * FROM 表名称 12345678910111213141516171819-- 表station取个别名叫s，表station中不包含 字段id=13或者14 的，并且id不等于4的 查询出来，只显示idSELECT s.id from station s WHERE id in (13,14) and id not in (4);-- 从表 Persons 选取 LastName 列的数据SELECT LastName FROM Persons-- 从表 users 选取 id=3 的数据，并只拉一条数据(据说能优化性能)SELECT * FROM users where id=3 limit 1-- 结果集中会自动去重复数据SELECT DISTINCT Company FROM Orders -- 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，-- 结果集显示 Persons表的 LastName、FirstName字段，Orders表的OrderNo字段SELECT p.LastName, p.FirstName, o.OrderNo FROM Persons p, Orders o WHERE p.Id_P = o.Id_P -- gbk 和 utf8 中英文混合排序最简单的办法 -- ci是 case insensitive, 即 “大小写不敏感”SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using gbk) collate gbk_chinese_ci;SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using utf8) collate utf8_unicode_ci; UPDATE Update 语句用于修改表中的数据。语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 12345-- update语句设置字段值为另一个结果取出来的字段update user set name = (select name from user1 where user1 .id = 1 )where id = (select id from user2 where user2 .name='小苏');-- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段UPDATE `orders` set title='这里是标题' WHERE id=1; INSERT INSERT INTO 语句用于向表格中插入新的行。语法：INSERT INTO 表名称 VALUES (值1, 值2,....)语法：INSERT INTO 表名称 (列1, 列2,...) VALUES (值1, 值2,....) 123456789101112-- 向表 Persons 插入一条字段 LastName = JSLite 字段 Address = shanghaiINSERT INTO Persons (LastName, Address) VALUES ('JSLite', 'shanghai');-- 向表 meeting 插入 字段 a=1 和字段 b=2INSERT INTO meeting SET a=1,b=2;-- -- SQL实现将一个表的数据插入到另外一个表的代码-- 如果只希望导入指定字段，可以用这种方法：-- INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表;INSERT INTO orders (user_account_id, title) SELECT m.user_id, m.title FROM meeting m where m.id=1;-- 向表 charger 插入一条数据，已存在就对表 charger 更新 `type`,`update_at` 字段；INSERT INTO `charger` (`id`,`type`,`create_at`,`update_at`) VALUES (3,2,'2017-05-18 11:06:17','2017-05-18 11:06:17') ON DUPLICATE KEY UPDATE `id`=VALUES(`id`), `type`=VALUES(`type`), `update_at`=VALUES(`update_at`); DELETE DELETE 语句用于删除表中的行。语法：DELETE FROM 表名称 WHERE 列名称 = 值 12345678-- 在不删除table_name表的情况下删除所有的行，清空表。DELETE FROM table_name-- 或者DELETE * FROM table_name-- 删除 Person表字段 LastName = 'JSLite' DELETE FROM Person WHERE LastName = 'JSLite' -- 删除 表meeting id 为2和3的两条数据DELETE from meeting where id in (2,3); WHERE WHERE 子句用于规定选择的标准。语法：SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 12-- 从表 Persons 中选出 Year 字段大于 1965 的数据SELECT * FROM Persons WHERE Year&gt;1965 AND 和 OR AND - 如果第一个条件和第二个条件都成立；OR - 如果第一个条件和第二个条件中只要有一个成立； AND1234567-- 删除 meeting 表字段 -- id=2 并且 user_id=5 的数据 和-- id=3 并且 user_id=6 的数据 DELETE from meeting where id in (2,3) and user_id in (5,6);-- 使用 AND 来显示所有姓为 "Carter" 并且名为 "Thomas" 的人：SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'; OR12-- 使用 OR 来显示所有姓为 "Carter" 或者名为 "Thomas" 的人：SELECT * FROM Persons WHERE firstname='Thomas' OR lastname='Carter' ORDER BY 语句默认按照升序对记录进行排序。ORDER BY - 语句用于根据指定的列对结果集进行排序。DESC - 按照降序对记录进行排序。ASC - 按照顺序对记录进行排序。 12345678-- Company在表Orders中为字母，则会以字母顺序显示公司名称SELECT Company, OrderNumber FROM Orders ORDER BY Company-- 后面跟上 DESC 则为降序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC-- Company以降序显示公司名称，并OrderNumber以顺序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC IN IN - 操作符允许我们在 WHERE 子句中规定多个值。IN - 操作符用来指定范围，范围中的每一条，都进行匹配。IN取值规律，由逗号分割，全部放置括号中。语法：SELECT &quot;字段名&quot;FROM &quot;表格名&quot;WHERE &quot;字段名&quot; IN (&#39;值一&#39;, &#39;值二&#39;, ...); 12-- 从表 Persons 选取 字段 LastName 等于 Adams、CarterSELECT * FROM Persons WHERE LastName IN ('Adams','Carter') NOT NOT - 操作符总是与其他操作符一起使用，用在要过滤的前面。 1SELECT vend_id, prod_name FROM Products WHERE NOT vend_id = 'DLL01' ORDER BY prod_name; UNION UNION - 操作符用于合并两个或多个 SELECT 语句的结果集。 123456789-- 列出所有在中国表（Employees_China）和美国（Employees_USA）的不同的雇员名SELECT E_Name FROM Employees_China UNION SELECT E_Name FROM Employees_USA-- 列出 meeting 表中的 pic_url，-- station 表中的 number_station 别名设置成 pic_url 避免字段不一样报错-- 按更新时间排序SELECT id,pic_url FROM meeting UNION ALL SELECT id,number_station AS pic_url FROM station ORDER BY update_at;-- 通过 UNION 语法同时查询了 products 表 和 comments 表的总记录数，并且按照 count 排序SELECT 'product' AS type, count(*) as count FROM `products` union select 'comment' as type, count(*) as count FROM `comments` order by count; AS as - 可理解为：用作、当成，作为；别名一般是重命名列名或者表名。语法：select column_1 as 列1,column_2 as 列2 from table as 表 12345678910111213141516SELECT * FROM Employee AS emp-- 这句意思是查找所有Employee 表里面的数据，并把Employee表格命名为 emp。-- 当你命名一个表之后，你可以在下面用 emp 代替 Employee.-- 例如 SELECT * FROM emp.SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders-- 列出表 Orders 字段 OrderPrice 列最大值，-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice-- 显示表 users_profile 中的 name 列SELECT t.name from (SELECT * from users_profile a) AS t;-- 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up-- 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id-- 结果集只显示mobile、name两列SELECT ua.mobile,up.name FROM user_accounts as ua INNER JOIN users_profile as up ON ua.id = up.user_id; JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 JOIN: 如果表中有至少一个匹配，则返回行 INNER JOIN:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 只要其中一个表中存在匹配，就返回行 12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName; SQL 函数COUNT COUNT 让我们能够数出在表格中有多少笔资料被选出来。语法：SELECT COUNT(&quot;字段名&quot;) FROM &quot;表格名&quot;; 1234567-- 表 Store_Information 有几笔 store_name 栏不是空白的资料。-- "IS NOT NULL" 是 "这个栏位不是空白" 的意思。SELECT COUNT (Store_Name) FROM Store_Information WHERE Store_Name IS NOT NULL; -- 获取 Persons 表的总数SELECT COUNT(1) AS totals FROM Persons;-- 获取表 station 字段 user_id 相同的总数select user_id, count(*) as totals from station group by user_id; MAX MAX 函数返回一列中的最大值。NULL 值不包括在计算中。语法：SELECT MAX(&quot;字段名&quot;) FROM &quot;表格名&quot; 123-- 列出表 Orders 字段 OrderPrice 列最大值，-- 结果集列不显示 OrderPrice 显示 LargestOrderPriceSELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders 触发器 语法：create trigger &lt;触发器名称&gt;{ before | after} # 之前或者之后出发insert | update | delete # 指明了激活触发程序的语句的类型on &lt;表名&gt; # 操作哪张表for each row # 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。&lt;触发器SQL语句&gt; 123456789101112delimiter $CREATE TRIGGER set_userdate BEFORE INSERT on `message`for EACH ROWBEGIN set @statu = new.status; -- 声明复制变量 statu if @statu = 0 then -- 判断 statu 是否等于 0 UPDATE `user_accounts` SET status=1 WHERE openid=NEW.openid; end if;END$DELIMITER ; -- 恢复结束符号 OLD和NEW不区分大小写 NEW 用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用OLD.col_name，没有新行。 OLD 用OLD.col_name来引用更新前的某一行的列 添加索引普通索引(INDEX) 语法：ALTER TABLE 表名字 ADD INDEX 索引名字 ( 字段名字 ) 1234567891011121314151617-- –直接创建索引CREATE INDEX index_user ON user(title)-- –修改表结构的方式添加索引ALTER TABLE table_name ADD INDEX index_name ON (column(length))-- 给 user 表中的 name字段 添加普通索引(INDEX)ALTER TABLE `table` ADD INDEX index_name (name)-- –创建表的时候同时创建索引CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT , `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL , `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL , `time` int(10) NULL DEFAULT NULL , PRIMARY KEY (`id`), INDEX index_name (title(length)))-- –删除索引DROP INDEX index_name ON table 主键索引(PRIMARY key) 语法：ALTER TABLE 表名字 ADD PRIMARY KEY ( 字段名字 ) 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 唯一索引(UNIQUE) 语法：ALTER TABLE 表名字 ADD UNIQUE (字段名字) 12-- 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)ALTER TABLE `user` ADD UNIQUE (creattime); 全文索引(FULLTEXT) 语法：ALTER TABLE 表名字 ADD FULLTEXT (字段名字) 12-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)ALTER TABLE `user` ADD FULLTEXT (description); 添加多列索引 语法：ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3) 12-- 给 user 表中的 name、city、age 字段添加名字为name_city_age的普通索引(INDEX)ALTER TABLE user ADD INDEX name_city_age (name(10),city,age); 建立索引的时机在WHERE和JOIN中出现的列需要建立索引，但也不完全如此： MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN使用索引 某些时候的LIKE也会使用索引。 在LIKE以通配符%和_开头作查询时，MySQL不会使用索引。 12345678-- 此时就需要对city和age建立索引，-- 由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。SELECT t.Name FROM mytable t LEFT JOIN mytable m ON t.Name=m.username WHERE m.age=20 AND m.city='上海';SELECT * FROM mytable WHERE username like'admin%'; -- 而下句就不会使用：SELECT * FROM mytable WHEREt Name like'%admin'; -- 因此，在使用LIKE时应注意以上的区别。 索引的注意事项 索引不会包含有NULL值的列 使用短索引 不要在列上进行运算 索引会失效 创建后表的修改添加列 语法：alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例: 123456-- 在表students的最后追加列 address: alter table students add address char(60);-- 在名为 age 的列后插入列 birthday: alter table students add birthday date after age;-- 在名为 number_people 的列后插入列 weeks: alter table students add column `weeks` varchar(5) not null default "" after `number_people`; 修改列 语法：alter table 表名 change 列名称 列新名称 新数据类型; 123456789-- 将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default "-";-- 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;-- 修改 COMMENT 前面必须得有类型属性alter table students change name name char(16) COMMENT '这里是名字';-- 修改列属性的时候 建议使用modify,不需要重建表-- change用于修改列名字，这个需要重建表alter table meeting modify `weeks` varchar(20) NOT NULL DEFAULT "" COMMENT "开放日期 周一到周日：0~6，间隔用英文逗号隔开"; 删除列 语法：alter table 表名 drop 列名称; 12-- 删除表students中的 birthday 列: alter table students drop birthday; 重命名表 语法：alter table 表名 rename 新表名; 12-- 重命名 students 表为 workmates: alter table students rename workmates; 清空表数据 方法一：delete from 表名;方法二：truncate from &quot;表名&quot;; DELETE:1. DML语言;2. 可以回退;3. 可以有条件的删除; TRUNCATE:1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。 1234-- 清空表为 workmates 里面的数据，不删除表。 delete from workmates;-- 删除workmates表中的所有数据，且无法恢复truncate from workmates; 删除整张表 语法：drop table 表名; 12-- 删除 workmates 表: drop table workmates; 删除整个数据库 语法：drop database 数据库名; 12-- 删除 samp_db 数据库: drop database samp_db; 个人小程序]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库 （三）]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93-%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇着重讲选择器$()选择器本例我们主要修改wclimb.init=function(selector){}里面的代码将wclimb.init代码修改为：1234567891011121314151617181920var domif (!selector) return wclimb.Z()else if (typeof selector == 'string') &#123; dom = wclimb.qsa(document, selector)&#125;else if (typeof selector == 'function')&#123; return wclimb.ready(selector)&#125;else&#123; if (isArray(selector)) &#123; dom = compact(selector) &#125; else if (wclimb.isZ(selector)) return selector else&#123; if (isObject(selector)) dom = [selector], selector = null ; else dom=wclimb.qsa(document,selector) &#125;&#125;return wclimb.Z(dom, selector) 首先判断是否存在selector，如果不存在则直接return 然后判断是否是字符串类型，如$(&#39;a b&#39;)，将选择的元素保存起来 如果是函数则return wclimb.ready(selector)就是我们经常用的$(function(){}) 后面判断是否是当前对象的实例（用了isZ方法）还有判断是否是数组或对象 我们先在函数顶部添加如下123emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filterslice = emptyArray.slicefunction compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; emptyArray = []，避免出现每次都重复创建的一个数组[]然后拿到数组里面的方法compact就是一个数组筛选，如果某个元素不存在$([1,2,,,4]);只会创建一个[1,2,4]的数组 wclimb.qsa方法1234567891011121314151617wclimb.qsa=function(element, selector)&#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = /^[\w-]*$/.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it's not simple, and we need to query all )&#125; 这里我直接用了zepto的代码wclimb.init=function(selector){}里的代码还使用了判断数据类型的代码isArray`isObject` 判断数据类型在函数外面添加如下代码来进行数据类型判断 123456789101112// 判断类型var obj_i=&#123;&#125;;['Boolean', 'Number','String', 'Function', 'Array' ,'Date', 'RegExp', 'Object' ,'Error'].forEach(function(el,idx)&#123; obj_i["[object " + el + "]"] = el.toLowerCase()&#125;)function type(obj) &#123; return obj == null ? String(obj) : obj_i[Object.prototype.toString.call(obj)] || "object"&#125;function isObject(obj) &#123; return type(obj) == "object" &#125; function isArray(obj) &#123; return type(obj) == "array" &#125;function isString(obj) &#123; return type(obj) == "string" &#125; wclimb.ready函数在外面设置如下函数123456wclimb.ready = function(fn) &#123; document.addEventListener('DOMContentLoaded',function() &#123; fn &amp;&amp; fn(); &#125;,false); document.removeEventListener('DOMContentLoaded',fn,true);&#125;; wclimb.isZ函数下面代码判断object是不是wclimb.Z的实例123wclimb.isZ = function(object) &#123; return object instanceof wclimb.Z&#125; 现在试试代码吧，我们顺便把addClass里判断hasClass代码注释去掉了 123456789101112&lt;script&gt; // ready $(function()&#123; alert(1) &#125;) // addClass $('p').addClass('a b') // 实例 console.log($(this)) // 数组 $([1,23,3,,4])&lt;/script&gt; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131(function()&#123; var wclimb = &#123;&#125;,$ emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter slice = emptyArray.slice function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom if (!selector) return wclimb.Z() else if (typeof selector == 'string') &#123; dom = wclimb.qsa(document, selector) &#125; else if (typeof selector == 'function')&#123; return wclimb.ready(selector) &#125; else&#123; if (isArray(selector)) &#123; dom = compact(selector) &#125; else if (wclimb.isZ(selector)) return selector else&#123; if (isObject(selector)) dom = [selector], selector = null ; else dom=wclimb.qsa(document,selector) &#125; &#125; return wclimb.Z(dom, selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; function className(node, value)&#123; var klass = node.className || '' if (value === undefined) return klass node.className = value &#125; wclimb.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;, addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!('className' in this)) return classList = []; var cls = className(this) name.split(/\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? " " : "") + classList.join(" ")) &#125;) &#125;, hasClass : function(cls) &#123; var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)'); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this; &#125; &#125; wclimb.ready = function(fn) &#123; document.addEventListener('DOMContentLoaded',function() &#123; fn &amp;&amp; fn(); &#125;,false); document.removeEventListener('DOMContentLoaded',fn,true); &#125;; wclimb.qsa=function(element, selector)&#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = /^[\w-]*$/.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it's not simple, and we need to query all ) &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; wclimb.isZ = function(object) &#123; return object instanceof wclimb.Z &#125; // 判断类型 var obj_i=&#123;&#125;; ['Boolean', 'Number','String', 'Function', 'Array' ,'Date', 'RegExp', 'Object' ,'Error'].forEach(function(el,idx)&#123; obj_i["[object " + el + "]"] = el.toLowerCase() &#125;) function type(obj) &#123; return obj == null ? String(obj) : obj_i[Object.prototype.toString.call(obj)] || "object" &#125; function isObject(obj) &#123; return type(obj) == "object" &#125; function isArray(obj) &#123; return type(obj) == "array" &#125; function isString(obj) &#123; return type(obj) == "string" &#125; window.$ = window.wclimb = $&#125;)()]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（二）]]></title>
    <url>%2F2017%2F07%2F17%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[距离上一篇zepto源码分析已经过去大半个月，想想自己都过意不去，不过之前分享了一篇node博客教程，还算干了点正事。接下来我们继续封装自己的库吧 上节代码概览12345678910111213141516171819202122232425262728293031323334(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() each方法 在wclimb.Z.prototype=Z.prototype=里面添加方法each 12345678wclimb.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;&#125; 通过数组的every方法进行遍历，然后看看每次callback是不是都不是false，如果是则结束遍历 最后通过 return this 来达到链式调用的效果 addClass方法继续在里面添加addClass方法 123456789101112131415161718addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!('className' in this)) return classList = []; var cls = className(this) // newName = funcArg(this, name, idx, cls) name.split(/\s+/g).forEach(function(klass)&#123; // if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? " " : "") + classList.join(" ")) &#125;)&#125; 我们先判断name存在与否，没有就直接return this，支持链式调用 新建一个数组，存放我们要添加的class，因为可能要同时添加多个 通过调用className方法来获取之前的class，并保存起来。clasName方法在下面 我们添加class一般是这样addClass(&#39;a b c&#39;)，所以我们通过正则表达式把他们用空格分开/\s+/g,用+的原因是，可能会有多个空格的存在，接着对他们进行循环 通过hasClass判断之前是否已经存在需要添加的class，如果有就push到classList数组里面。我们先注释掉hasClass这段代码，因为其中用到了$(this) ,querySelector是不支持的哟，所以后面我们得作判断，判断$()这里面放的是元素、函数、类数组等等。 最后通过函数className方法把他们用空格连接起来 发现里面有一个没有声明的className方法所以我们在wclimb.Z.prototype=Z.prototype=上面声明该函数1234567//获取或者设置classfunction className(node, value)&#123; var klass = node.className || '' if (value === undefined) return klass node.className = value&#125; 该方法主要是获取class和设置class的作用 hasClass方法12345678hasClass : function(cls) &#123; var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)'); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this;&#125; 通过正则匹配，如果存在则返回true，否则返回false，最后return this支持链式调用 现在来试试效果吧12345html: &lt;p class="a"&gt;&lt;/p&gt;js: $('p').addClass('test other') // &lt;p class="a test other"&gt;&lt;/p&gt; console.log($('p').hasClass('a')) // true 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; function className(node, value)&#123;//获取或者设置class var klass = node.className || '' if (value === undefined) return klass node.className = value &#125; wclimb.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;, addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!('className' in this)) return classList = []; var cls = className(this) name.split(/\s+/g).forEach(function(klass)&#123; // if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? " " : "") + classList.join(" ")) &#125;) &#125;, hasClass : function(cls) &#123; var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)'); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this; &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)()]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node+Koa2+Mysql 搭建简易博客]]></title>
    <url>%2F2017%2F07%2F12%2FNode-Koa2-Mysql-%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Koa2-blog 2018-1-5 更新教程（新增上传头像、新增分页、样式改版、发布文章和评论支持markdown语法）现在GitHub的代码结构有变，优化了蛮多东西 Node+Koa2+Mysql 搭建简易博客 预览地址http://blog.wclimb.site 写在前面本篇教程一方面是为了自己在学习的过程加深记忆，也是总结的过程。另一方面给对这方面不太了解的同学以借鉴经验。如发现问题还望指正，如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^ps：关于markdown代码缩进问题，看起来不太舒服，但复制到编辑器是正常的哟！ 演示效果 开发环境 nodejs v8.1.0 koa v2.3.0 mysql v5.7.0 准备工作文中用到了promise、async await等语法，所以你需要一点es6的语法，传送门当然是阮老师的教程了 http://es6.ruanyifeng.com/ 如果你已经配置好node和mysql可以跳过 经常会有人问报错的问题，运行出错大部分是因为不支持async，升级node版本可解决 1$ node -v 查看你的node版本，如果过低则去nodejs官网下载替换之前的版本 下载mysql，并设置好用户名和密码，默认可以为用户名：root，密码：123456 1进入到 bin 目录下 比如 cd C:\Program Files\MySQL\MySQL Server 5.7\bin 然后开启mysql1$ mysql -u root -p 输入密码之后创建database(数据库)，nodesql是我们创建的数据库1$ create database nodesql; 记住sql语句后面一定要跟;符号，接下来看看我们创建好的数据库列表 1$ show databases; 启用创建的数据库1$ use nodesql; 查看数据库中的表1$ show tables; 显示Empty set (0.00 sec)，因为我们还没有建表，稍后会用代码建表注释：这是后面建表之后的状态 目录结构 config 存放默认文件 lib 存放操作数据库文件 middlewares 存放判断登录与否文件 public 存放样式和头像文件 routes 存放路由文件 views 存放模板文件 index 程序主文件 package.json 包括项目名、作者、依赖等等 首先我们创建koa2-blog文件夹，然后cd koa2-blog1接着使用 npm init 来创建package.json 接着安装包，安装之前我们使用cnpm安装1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 1$ cnpm i koa koa-bodyparser koa-mysql-session koa-router koa-session-minimal koa-static koa-views md5 moment mysql ejs markdown-it chai mocha koa-static-cache --save-dev 各模块用处 koa node框架 koa-bodyparser 表单解析中间件 koa-mysql-session、koa-session-minimal 处理数据库的中间件 koa-router 路由中间件 koa-static 静态资源加载中间件 ejs 模板引擎 md5 密码加密 moment 时间中间件 mysql 数据库 markdown-it markdown语法 koa-views 模板呈现中间件 chai mocha 测试使用 koa-static-cache 文件缓存 在文件夹里面新建所需文件 首先配置config我们新建default.js文件 123456789101112131415const config = &#123; // 启动端口 port: 3000, // 数据库配置 database: &#123; DATABASE: &apos;nodesql&apos;, USERNAME: &apos;root&apos;, PASSWORD: &apos;123456&apos;, PORT: &apos;3306&apos;, HOST: &apos;localhost&apos; &#125;&#125;module.exports = config 这是我们所需的一些字段，包括端口和数据库连接所需，最后我们把它exports暴露出去，以便可以在别的地方使用 配置index.js文件index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const Koa=require('koa');const path=require('path')const bodyParser = require('koa-bodyparser');const ejs=require('ejs');const session = require('koa-session-minimal');const MysqlStore = require('koa-mysql-session');const config = require('./config/default.js');const router=require('koa-router')const views = require('koa-views')// const koaStatic = require('koa-static')const staticCache = require('koa-static-cache')const app = new Koa()// session存储配置const sessionMysqlConfig= &#123; user: config.database.USERNAME, password: config.database.PASSWORD, database: config.database.DATABASE, host: config.database.HOST,&#125;// 配置session中间件app.use(session(&#123; key: 'USER_SID', store: new MysqlStore(sessionMysqlConfig)&#125;))// 配置静态资源加载中间件// app.use(koaStatic(// path.join(__dirname , './public')// ))// 缓存app.use(staticCache(path.join(__dirname, './public'), &#123; dynamic: true &#125;, &#123; maxAge: 365 * 24 * 60 * 60&#125;))app.use(staticCache(path.join(__dirname, './images'), &#123; dynamic: true &#125;, &#123; maxAge: 365 * 24 * 60 * 60&#125;))// 配置服务端模板渲染引擎中间件app.use(views(path.join(__dirname, './views'), &#123; extension: 'ejs'&#125;))app.use(bodyParser(&#123; formLimit: '1mb'&#125;))// 路由(我们先注释三个，等后面添加好了再取消注释，因为我们还没有定义路由，稍后会先实现注册)//app.use(require('./routers/signin.js').routes())app.use(require('./routers/signup.js').routes())//app.use(require('./routers/posts.js').routes())//app.use(require('./routers/signout.js').routes())app.listen(3000)console.log(`listening on port $&#123;config.port&#125;`) 我们使用koa-session-minimal`koa-mysql-session来进行数据库的操作 使用koa-static配置静态资源，目录设置为public使用ejs模板引擎 使用koa-bodyparser来解析提交的表单信息 使用koa-router做路由 使用koa-static-cache`来缓存文件之前我们配置了default.js，我们就可以在这里使用了首先引入进来 var config = require(‘./config/default.js’);然后在数据库的操作的时候，如config.database.USERNAME，得到的就是root。 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog 配置lib的mysql.js文件关于数据库的使用这里介绍一下，首先我们建立了数据库的连接池，以便后面的操作都可以使用到，我们创建了一个函数query，通过返回promise的方式以便可以方便用.then()来获取数据库返回的数据，然后我们定义了三个表的字段，通过createTable来创建我们后面所需的三个表，包括posts(存储文章)，users(存储用户)，comment(存储评论)，create table if not exists users()表示如果users表不存在则创建该表，避免每次重复建表报错的情况。后面我们定义了一系列的方法，最后把他们exports暴露出去。 这里只介绍注册用户insertData，后续的可以自行查看，都差不多 12345// 注册用户let insertData = function( value ) &#123; let _sql = "insert into users set name=?,pass=?,avator=?,moment=?;" return query( _sql, value )&#125; 我们写了一个_sql的sql语句，意思是插入到users的表中（在这之前我们已经建立了users表）然后要插入的数据分别是name、pass、avator、moment，就是用户名、密码、头像、注册时间，最后调用query函数把sql语句传进去（之前的写法是&quot;insert into users(name,pass) values(?,?);&quot;,换成现在得更容易理解） lib/mysql.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225var mysql = require('mysql');var config = require('../config/default.js')var pool = mysql.createPool(&#123; host : config.database.HOST, user : config.database.USERNAME, password : config.database.PASSWORD, database : config.database.DATABASE&#125;);let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; reject( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;// let query = function( sql, values ) &#123;// pool.getConnection(function(err, connection) &#123;// // 使用连接// connection.query( sql,values, function(err, rows) &#123;// // 使用连接执行查询// console.log(rows)// connection.release();// //连接不再使用，返回到连接池// &#125;);// &#125;);// &#125;let users = `create table if not exists users( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, pass VARCHAR(100) NOT NULL, avator VARCHAR(100) NOT NULL, moment VARCHAR(100) NOT NULL, PRIMARY KEY ( id ) );`let posts = `create table if not exists posts( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, title TEXT(0) NOT NULL, content TEXT(0) NOT NULL, md TEXT(0) NOT NULL, uid VARCHAR(40) NOT NULL, moment VARCHAR(100) NOT NULL, comments VARCHAR(200) NOT NULL DEFAULT '0', pv VARCHAR(40) NOT NULL DEFAULT '0', avator VARCHAR(100) NOT NULL, PRIMARY KEY ( id ) );`let comment = `create table if not exists comment( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, content TEXT(0) NOT NULL, moment VARCHAR(40) NOT NULL, postid VARCHAR(40) NOT NULL, avator VARCHAR(100) NOT NULL, PRIMARY KEY ( id ) );`let createTable = function( sql ) &#123; return query( sql, [] )&#125;// 建表createTable(users)createTable(posts)createTable(comment)// 注册用户let insertData = function( value ) &#123; let _sql = "insert into users set name=?,pass=?,avator=?,moment=?;" return query( _sql, value )&#125;// 删除用户let deleteUserData = function( name ) &#123; let _sql = `delete from users where name="$&#123;name&#125;";` return query( _sql )&#125;// 查找用户let findUserData = function( name ) &#123; let _sql = `select * from users where name="$&#123;name&#125;";` return query( _sql )&#125;// 发表文章let insertPost = function( value ) &#123; let _sql = "insert into posts set name=?,title=?,content=?,md=?,uid=?,moment=?,avator=?;" return query( _sql, value )&#125;// 更新文章评论数let updatePostComment = function( value ) &#123; let _sql = "update posts set comments=? where id=?" return query( _sql, value )&#125;// 更新浏览数let updatePostPv = function( value ) &#123; let _sql = "update posts set pv=? where id=?" return query( _sql, value )&#125;// 发表评论let insertComment = function( value ) &#123; let _sql = "insert into comment set name=?,content=?,moment=?,postid=?,avator=?;" return query( _sql, value )&#125;// 通过名字查找用户let findDataByName = function ( name ) &#123; let _sql = `select * from users where name="$&#123;name&#125;";` return query( _sql)&#125;// 通过文章的名字查找用户let findDataByUser = function ( name ) &#123; let _sql = `select * from posts where name="$&#123;name&#125;";` return query( _sql)&#125;// 通过文章id查找let findDataById = function ( id ) &#123; let _sql = `select * from posts where id="$&#123;id&#125;";` return query( _sql)&#125;// 通过评论id查找let findCommentById = function ( id ) &#123; let _sql = `select * FROM comment where postid="$&#123;id&#125;";` return query( _sql)&#125;// 查询所有文章let findAllPost = function () &#123; let _sql = ` select * FROM posts;` return query( _sql)&#125;// 查询分页文章let findPostByPage = function (page) &#123; let _sql = ` select * FROM posts limit $&#123;(page-1)*10&#125;,10;` return query( _sql)&#125;// 查询个人分页文章let findPostByUserPage = function (name,page) &#123; let _sql = ` select * FROM posts where name="$&#123;name&#125;" order by id desc limit $&#123;(page-1)*10&#125;,10 ;` return query( _sql)&#125;// 更新修改文章let updatePost = function(values)&#123; let _sql = `update posts set title=?,content=?,md=? where id=?` return query(_sql,values)&#125;// 删除文章let deletePost = function(id)&#123; let _sql = `delete from posts where id = $&#123;id&#125;` return query(_sql)&#125;// 删除评论let deleteComment = function(id)&#123; let _sql = `delete from comment where id=$&#123;id&#125;` return query(_sql)&#125;// 删除所有评论let deleteAllPostComment = function(id)&#123; let _sql = `delete from comment where postid=$&#123;id&#125;` return query(_sql)&#125;// 查找评论数let findCommentLength = function(id)&#123; let _sql = `select content from comment where postid in (select id from posts where id=$&#123;id&#125;)` return query(_sql)&#125;// 滚动无限加载数据let findPageById = function(page)&#123; let _sql = `select * from posts limit $&#123;(page-1)*5&#125;,5;` return query(_sql)&#125;// 评论分页let findCommentByPage = function(page,postId)&#123; let _sql = `select * from comment where postid=$&#123;postId&#125; order by id desc limit $&#123;(page-1)*10&#125;,10;` return query(_sql)&#125;module.exports = &#123; query, createTable, insertData, deleteUserData, findUserData, findDataByName, insertPost, findAllPost, findPostByPage, findPostByUserPage, findDataByUser, findDataById, insertComment, findCommentById, updatePost, deletePost, deleteComment, findCommentLength, updatePostComment, deleteAllPostComment, updatePostPv, findPageById, findCommentByPage&#125; 下面是我们建的表 users posts comment id id id name name name pass title content avator content moment moment md postid - uid avator - moment - - comments - - pv - - avator - id主键递增 name: 用户名 pass：密码 avator：头像 title：文章标题 content：文章内容和评论 md：markdown语法 uid：发表文章的用户id moment：创建时间 comments：文章评论数 pv：文章浏览数 postid：文章id 现在感觉有点枯燥，那我们先来实现一下注册吧 实现注册页面routers/singup.js12345678910111213141516const router = require('koa-router')();const userModel = require('../lib/mysql.js');const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginconst moment = require('moment');const fs = require('fs')// 注册页面router.get('/signup', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signup', &#123; session: ctx.session, &#125;)&#125;) module.exports = router 使用get方式得到’/signup’页面，然后渲染signup模板，这里我们还没有在写signup.ejs views/signup.ejs 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post"&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="请输入用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="请输入密码" class="password" type="password" name="password"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input placeholder="请确认密码" class="repeatpass" type="password" name="repeatpass"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;上传头像：&lt;/label&gt; &lt;input type="file" name="avator" id="avator"&gt; &lt;input type="hidden" id="avatorVal"&gt; &lt;img class="preview" alt="预览头像"&gt; &lt;/div&gt; &lt;div class="submit"&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们先安装supervisor 1$ cnpm i supervisor -g supervisor的作用是会监听文件的变化，而我们修改文件之后不必去重启程序1supervisor --harmony index 现在访问 localhost:3000/signup 看看效果吧。注意数据库一定要是开启的状态，不能关闭 完善注册功能首先我们来完善一下样式吧，稍微美化一下 public/index.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360body,header,ul,li,p,div,html,span,h3,a,blockquote &#123; margin: 0; padding: 0; color: #333;&#125;body &#123; margin-bottom: 20px;&#125;ul,li&#123; list-style-type: none;&#125;a &#123; text-decoration: none;&#125;header &#123; width: 60%; margin: 20px auto;&#125;header:after&#123; content: ''; clear: both; display: table;&#125;header .user_right&#123; float: right&#125;header .user_right .active&#123; color: #5FB878; background: #fff; border: 1px solid #5FB878; box-shadow: 0 5px 5px #ccc;&#125;header .user_name &#123; float: left&#125;.user_name &#123; font-size: 20px;&#125;.has_user a,.has_user span,.none_user a &#123; padding: 5px 15px; background: #5FB878; border-radius: 15px; color: #fff; cursor: pointer; border: 1px solid #fff; transition: all 0.3s;&#125;.has_user a:hover,.has_user span:hover&#123; color: #5FB878; background: #fff; border: 1px solid #5FB878; box-shadow: 0 5px 5px #ccc;&#125;.posts&#123; border-radius: 4px; border: 1px solid #ddd;&#125;.posts &gt; li&#123; padding: 10px; position: relative; padding-bottom: 40px;&#125;.posts .comment_pv&#123; position: absolute; bottom: 5px; right: 10px;&#125;.posts .author&#123; position: absolute; left: 10px; bottom: 5px;&#125;.posts .author span&#123; margin-right: 5px;&#125;.posts &gt; li:hover &#123; background: #f2f2f2;&#125;.posts &gt; li:hover pre&#123; border: 1px solid #666;&#125;.posts &gt; li:hover .content&#123; border-top: 1px solid #fff; border-bottom: 1px solid #fff;&#125;.posts &gt; li + li&#123; border-top: 1px solid #ddd;&#125;.posts li .title span&#123; position: absolute; left: 10px; top: 10px; color: #5FB878; font-size: 14px;&#125;.posts li .title&#123; margin-left: 40px; font-size: 20px; color: #222;&#125;.posts .userAvator&#123; position: absolute; left: 3px; top: 3px; width: 40px; height: 40px; border-radius: 5px;&#125;.posts .content&#123; border-top: 1px solid #f2f2f2; border-bottom: 1px solid #f2f2f2; margin: 10px 0 0 0 ; padding: 10px 0; margin-left: 40px;&#125;.userMsg img&#123; width: 40px; height: 40px; border-radius: 5px; margin-right: 10px; vertical-align: middle; display: inline-block;&#125;.userMsg span&#123; font-size: 18px; color:#333; position: relative; top: 2px;&#125;.posts li img&#123; max-width: 100%;&#125;.spost .comment_pv&#123; position: absolute; top: 10px;&#125;.spost .edit &#123; position: absolute; right: 20px; bottom: 5px;&#125;.spost .edit p &#123; display: inline-block; margin-left: 10px;&#125;.comment_wrap &#123; width: 60%; margin: 20px auto;&#125;.submit &#123; display: block; width: 100px; height: 40px; line-height: 40px; text-align: center; border-radius: 4px; background: #5FB878; cursor: pointer; color: #fff; float: left; margin-top: 20px ; border:1px solid #fff;&#125;.submit:hover&#123; background: #fff; color: #5FB878; border:1px solid #5FB878;&#125;.comment_list&#123; border: 1px solid #ddd; border-radius: 4px;&#125;.cmt_lists:hover&#123; background: #f2f2f2;&#125;.cmt_lists + .cmt_lists&#123; border-top: 1px solid #ddd;&#125;.cmt_content &#123; padding: 10px; position: relative; border-radius: 4px; word-break: break-all;&#125;.cmt_detail&#123; margin-left: 48px;&#125;.cmt_content img&#123; max-width: 100%;&#125;/* .cmt_content:after &#123; content: '#content'; position: absolute; top: 5px; right: 5px; color: #aaa; font-size: 13px;&#125; */.cmt_name &#123; position: absolute; right: 8px; bottom: 5px; color: #333;&#125;.cmt_name a &#123; margin-left: 5px; color: #1E9FFF;&#125;.cmt_time&#123; position: absolute; font-size: 12px; right: 5px; top: 5px; color: #aaa&#125;.form &#123; margin: 0 auto; width: 50%; margin-top: 20px;&#125;textarea &#123; width: 100%; height: 150px; padding:10px 0 0 10px; font-size: 20px; border-radius: 4px; border: 1px solid #d7dde4; -webkit-appearance: none; resize: none;&#125;textarea#spContent&#123; width: 98%;&#125;.tips &#123; margin: 20px 0; color: #ec5051; text-align: center;&#125;.container &#123; width: 60%; margin: 0 auto;&#125;.form img.preview &#123; width:100px; height:100px; border-radius: 50%; display: none; margin-top:10px;&#125;input &#123; display: block; width: 100%; height: 35px; font-size: 18px; padding: 6px 7px; border-radius: 4px; border: 1px solid #d7dde4; -webkit-appearance: none;&#125;input:focus,textarea:focus&#123; outline: 0; box-shadow: 0 0 0 2px rgba(51,153,255,.2); border-color: #5cadff;&#125;input:hover,input:active,textarea:hover,textarea:active&#123; border-color: #5cadff;&#125;.create label &#123; display: block; margin: 10px 0;&#125;.comment_wrap form &#123; width: 100%; margin-bottom: 85px;&#125;.delete_comment,.delete_post &#123; cursor: pointer;&#125;.delete_comment:hover,.delete_post:hover,a:hover &#123; color: #ec5051;&#125;.disabled&#123; user-select: none; cursor: not-allowed !important;&#125;.error&#123; color: #ec5051;&#125;.success&#123; color: #1E9FFF;&#125;.container&#123; width: 60%; margin:0 auto;&#125;.message&#123; position: fixed; top: -100%; left: 50%; transform: translateX(-50%); padding: 10px 20px; background: rgba(0, 0, 0, 0.7); color: #fff; border-bottom-left-radius: 15px; border-bottom-right-radius: 15px; z-index: 99999;&#125;.markdown pre&#123; display: block; overflow-x: auto; padding: 0.5em; background: #F0F0F0; border-radius: 3px; border: 1px solid #fff;&#125;.markdown blockquote&#123; padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; margin: 10px 0;&#125;.markdown ul li&#123; list-style: circle; margin-top: 5px;&#125; 我们再把模板引擎的header和footer独立出来 /views/header.ejs顺便引入index.css和jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;koa2-blog&lt;/title&gt; &lt;link rel="icon" href="http://www.wclimb.site/images/avatar.png"&gt; &lt;link rel="stylesheet" href="/index.css"&gt; &lt;script src="http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; function fade(txt)&#123; $('.message').text(txt) $('.message').animate(&#123; top:0 &#125;) setTimeout(function()&#123; $('.message').animate(&#123; top: '-100%' &#125;) &#125;,1500) &#125; $(function()&#123; $('.signout').click(()=&gt;&#123; $.ajax(&#123; url: "/signout", type: "GET", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('登出成功') setTimeout(()=&gt;&#123; window.location.href = "/posts" &#125;,1500) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;div class="user_name"&gt; &lt;% if(session.user)&#123; %&gt; Hello,&lt;%= session.user %&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; 欢迎注册登录^_^ &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class="message"&gt;登录成功&lt;/div&gt; &lt;div class="user_right"&gt; &lt;% if(session.user)&#123; %&gt; &lt;div class="has_user"&gt; &lt;a target="__blank" href="https://github.com/wclimb/Koa2-blog"&gt;GitHub&lt;/a&gt; &lt;% if(type == 'all')&#123; %&gt; &lt;a class="active" href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'my')&#123; %&gt; &lt;a class="active" href="/posts?author=&lt;%= session.user %&gt;"&gt;我的文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/posts?author=&lt;%= session.user %&gt;"&gt;我的文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'create')&#123; %&gt; &lt;a class="active" href="/create"&gt;发表文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/create"&gt;发表文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;span class="signout"&gt;登出&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; &lt;div class="none_user has_user"&gt; &lt;a target="__blank" href="https://github.com/wclimb/Koa2-blog"&gt;GitHub&lt;/a&gt; &lt;% if(type == 'all')&#123; %&gt; &lt;a class="active" href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'signup')&#123; %&gt; &lt;a class="active" href="/signup"&gt;注册&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/signup"&gt;注册&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'signin')&#123; %&gt; &lt;a class="active" href="/signin"&gt;登录&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/signin"&gt;登录&lt;/a&gt; &lt;% &#125;%&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/header&gt; 首先我们看到用到了session.user，这个值从哪来呢？请看下面的代码1234567// 注册页面router.get('/signup', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signup', &#123; session: ctx.session, &#125;)&#125;) 我们可以看到我们向模板传了一个session值，session:ctx.session，这个值存取的就是用户的信息，包括用户名、登录之后的id等，session一般是你关闭浏览器就过期了，等于下次打开浏览器的时候就得重新登录了，用if判断他存不存在，就可以知道用户是否需要登录，如果不存在用户，则只显示全部文章 注册 登录 ,如果session.user存在则有登出的按钮。 在上面我们会看到我用了另外一个if判断，判断type类型，这样做的目的是比如我们登录注册页面，注册页面的导航会高亮，其实就是添加了class：active;之后我们每个ejs文件的头部会这样写&lt;%- include(&quot;header&quot;,{type:&#39;signup&#39;}) %&gt; 登录页面则是&lt;%- include(&quot;header&quot;,{type:&#39;signin&#39;}) %&gt; /views/footer.ejs123 &lt;/body&gt;&lt;/html&gt; 修改views/signup.ejs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;%- include("header",&#123;type:'signup'&#125;) %&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post"&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="请输入用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="请输入密码" class="password" type="password" name="password"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input placeholder="请确认密码" class="repeatpass" type="password" name="repeatpass"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;上传头像：&lt;/label&gt; &lt;input type="file" name="avator" id="avator"&gt; &lt;input type="hidden" id="avatorVal"&gt; &lt;img class="preview" alt="预览头像"&gt; &lt;/div&gt; &lt;div class="submit"&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(window).keyup(function (e) &#123; //console.log(e.keyCode) if (e.keyCode == 13) &#123; $('.submit').click() &#125; &#125;) $('#avator').change(function()&#123; if (this.files.length != 0) &#123; var file = this.files[0], reader = new FileReader(); if (!reader) &#123; this.value = ''; return; &#125;; console.log(file.size) if (file.size &gt;= 1024 * 1024 / 2) &#123; fade("请上传小于512kb的图片!") return &#125; reader.onload = function (e) &#123; this.value = ''; $('form .preview').attr('src', e.target.result) $('form .preview').fadeIn() $('#avatorVal').val(e.target.result) &#125;; reader.readAsDataURL(file); &#125;; &#125;) $('.submit').click(()=&gt;&#123; // console.log($('.form').serialize()) if ($('input[name=name]').val().trim() == '') &#123; fade('请输入用户名！') &#125;else if($('input[name=name]').val().match(/[&lt;'"&gt;]/g))&#123; fade('请输入合法字符！') &#125;else if($('#avatorVal').val() == '')&#123; fade('请上传头像！') &#125;else&#123; $.ajax(&#123; url: "/signup", data: &#123; name: $('input[name=name]').val(), password: $('input[name=password]').val(), repeatpass: $('input[name=repeatpass]').val(), avator: $('#avatorVal').val(), &#125;, type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg.data == 1) &#123; $('input').val('') fade('用户名存在') &#125; else if (msg.data == 2)&#123; fade('请输入重复的密码') &#125; else if(msg.data == 3)&#123; fade('注册成功') setTimeout(()=&gt;&#123; window.location.href="/signin" &#125;,1000) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;) &lt;/script&gt;&lt;% include footer %&gt; 先看我们请求的url地址，是’/signup’，为什么是这个呢？我们看下面这段代码(后面有完整的)12345678910router.post('/signup', async(ctx, next) =&gt; &#123; //console.log(ctx.request.body) let user = &#123; name: ctx.request.body.name, pass: ctx.request.body.password, repeatpass: ctx.request.body.repeatpass, avator: ctx.request.body.avator &#125; ....&#125; 我们的请求方式是post，地址是/signup所以走了这段代码，之后会获取我们输入的信息，通过ctx.request.body拿到 这里重点就在于ajax提交了，提交之后换回数据 1 2 3，然后分别做正确错误处理，把信息写在error和success中 修改routers/signup.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const router = require('koa-router')();const userModel = require('../lib/mysql.js');const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginconst moment = require('moment');const fs = require('fs')// 注册页面router.get('/signup', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signup', &#123; session: ctx.session, &#125;)&#125;)// post 注册router.post('/signup', async(ctx, next) =&gt; &#123; //console.log(ctx.request.body) let user = &#123; name: ctx.request.body.name, pass: ctx.request.body.password, repeatpass: ctx.request.body.repeatpass, avator: ctx.request.body.avator &#125; await userModel.findDataByName(user.name) .then(async (result) =&gt; &#123; console.log(result) if (result.length) &#123; try &#123; throw Error('用户已经存在') &#125; catch (error) &#123; //处理err console.log(error) &#125; // 用户存在 ctx.body = &#123; data: 1 &#125;;; &#125; else if (user.pass !== user.repeatpass || user.pass === '') &#123; ctx.body = &#123; data: 2 &#125;; &#125; else &#123; // ctx.session.user=ctx.request.body.name let base64Data = user.avator.replace(/^data:image\/\w+;base64,/, ""); let dataBuffer = new Buffer(base64Data, 'base64'); let getName = Number(Math.random().toString().substr(3)).toString(36) + Date.now() await fs.writeFile('./public/images/' + getName + '.png', dataBuffer, err =&gt; &#123; if (err) throw err; console.log('头像上传成功') &#125;); await userModel.insertData([user.name, md5(user.pass), getName, moment().format('YYYY-MM-DD HH:mm:ss')]) .then(res=&gt;&#123; console.log('注册成功',res) //注册成功 ctx.body = &#123; data: 3 &#125;; &#125;) &#125; &#125;)&#125;)module.exports = router 我们使用md5实现密码加密，长度是32位的 使用我们之前说的bodyParse来解析提交的数据，通过ctx.request.body得到 我们引入了数据库的操作 findDataByName和insertData，因为之前我们在/lib/mysql.js中已经把他们写好，并暴露出来了。意思是先从数据库里面查找注册的用户名，如果找到了证明该用户名已经被注册过了，如果没有找到则使用insertData增加到数据库中 ctx.body 是我们通过ajax提交之后给页面返回的数据，比如提交ajax成功之后msg.data=1的时候就代表用户存在，msg.data出现在后面的signup.ejs模板ajax请求中 上传头像之前要新建好文件夹，我们ajax发送的是base64的格式，然后使用fs.writeFile来生成图片 我们使用ajax来提交数据，方便来做成功错误的处理 模板引擎ejs我们使用的是ejs，语法可以见ejs 之前我们写了这么一段代码12345router.get('/signup',async (ctx,next)=&gt;&#123; await ctx.render('signup',&#123; session:ctx.session, &#125;)&#125;) 这里就用到了ejs所需的session 我们通过渲染signup.ejs模板，将值ctx.session赋值给session，之后我们就可以在signup.ejs中使用了ejs的常用标签为： &lt;% code %&gt;：运行 JavaScript 代码，不输出 &lt;%= code %&gt;：显示转义后的 HTML内容 &lt;%- code %&gt;：显示原始 HTML 内容 &lt;%= code %&gt;和&lt;%- code %&gt;的区别在于，&lt;%= code %&gt;不管你写什么都会原样输出，比如code为 &lt;strong&gt;hello&lt;/strong&gt;的时候 &lt;%= code %&gt; 会显示&lt;strong&gt;hello&lt;/strong&gt;而&lt;%- code %&gt;则显示加粗的hello 实现登录页面 修改 /routers/signin.js12345678910111213const router = require('koa-router')();const userModel = require('../lib/mysql.js')const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginrouter.get('/signin', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signin', &#123; session: ctx.session, &#125;)&#125;)module.exports=router 修改 /views/signin.ejs 123456789101112131415&lt;%- include("header",&#123;type:'signin'&#125;) %&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post "&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="密码" type="password" name="password"&gt; &lt;/div&gt; &lt;div class="submit"&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改 index.js 文件 把下面这段代码注释去掉，之前注释是因为我们没有写signin的路由，以免报错，后面还有文章页和登出页的路由，大家记住一下 1app.use(require('./routers/signin.js').routes()) 现在注册一下来看看效果吧1$ supervisor --harmony index 我们怎么查看我们注册好的账号和密码呢？打开mysql控制台 1$ select * from users; 这样刚刚我们注册的用户信息都出现了 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wclimb/Koa2-blog 登录页面修改signinrouters/signin.js123456789101112131415161718192021222324252627282930313233343536373839const router = require('koa-router')();const userModel = require('../lib/mysql.js')const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginrouter.get('/signin', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signin', &#123; session: ctx.session, &#125;)&#125;)router.post('/signin', async(ctx, next) =&gt; &#123; console.log(ctx.request.body) let name = ctx.request.body.name; let pass = ctx.request.body.password; await userModel.findDataByName(name) .then(result =&gt; &#123; let res = result if (name === res[0]['name'] &amp;&amp; md5(pass) === res[0]['pass']) &#123; ctx.body = true ctx.session.user = res[0]['name'] ctx.session.id = res[0]['id'] console.log('ctx.session.id', ctx.session.id) console.log('session', ctx.session) console.log('登录成功') &#125;else&#123; ctx.body = false console.log('用户名或密码错误!') &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125;)module.exports = router 我们进行登录操作，判断登录的用户名和密码是否有误，使用md5加密我们可以看到登录成功返回的结果是result 结果是这样的一个json数组：id：4 name：rrr pass：…[ RowDataPacket { id: 4, name: ‘rrr’, pass: ‘44f437ced647ec3f40fa0841041871cd’ } ] 修改views/signin.ejssignin.ejs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%- include("header",&#123;type:'signin'&#125;) %&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post "&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="密码" type="password" name="password"&gt; &lt;/div&gt; &lt;div class="submit"&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(window).keyup(function(e)&#123; //console.log(e.keyCode) if (e.keyCode == 13) &#123; $('.submit').click() &#125; &#125;) $('.submit').click(()=&gt;&#123; if ($('input[name=name]').val().trim() == '' || $('input[name=password]').val().trim() == '' ) &#123; fade('请输入用户名或密码') &#125;else&#123; console.log($('.form').serialize()) $.ajax(&#123; url: "/signin", data: $('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (!msg) &#123; $('input').val('') fade('用户名或密码错误') &#125; else&#123; fade('登录成功') setTimeout(()=&gt;&#123; window.location.href = "/posts" &#125;,1500) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;) &lt;/script&gt;&lt;% include footer %&gt; 我们增加了ajax请求，在routers/signin.js里，我们设置如果登录失败就返回false，登录成功返回true 12ctx.body = falsectx.body = true 那我们登录成功后要做跳转，可以看到window.location.href=&quot;/posts&quot;跳转到posts页面 全部文章修改routers/posts.js posts.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const router = require('koa-router')();const userModel = require('../lib/mysql.js')const moment = require('moment')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLogin;const md = require('markdown-it')(); // 重置到文章页router.get('/', async(ctx, next) =&gt; &#123; ctx.redirect('/posts')&#125;)// 文章页router.get('/posts', async(ctx, next) =&gt; &#123; let res, postsLength, name = decodeURIComponent(ctx.request.querystring.split('=')[1]); if (ctx.request.querystring) &#123; console.log('ctx.request.querystring', name) await userModel.findDataByUser(name) .then(result =&gt; &#123; postsLength = result.length &#125;) await userModel.findPostByUserPage(name,1) .then(result =&gt; &#123; res = result &#125;) await ctx.render('selfPosts', &#123; session: ctx.session, posts: res, postsPageLength:Math.ceil(postsLength / 10), &#125;) &#125; else &#123; await userModel.findPostByPage(1) .then(result =&gt; &#123; //console.log(result) res = result &#125;) await userModel.findAllPost() .then(result=&gt;&#123; postsLength = result.length &#125;) await ctx.render('posts', &#123; session: ctx.session, posts: res, postsLength: postsLength, postsPageLength: Math.ceil(postsLength / 10), &#125;) &#125;&#125;)// 首页分页，每次输出10条router.post('/posts/page', async(ctx, next) =&gt; &#123; let page = ctx.request.body.page; await userModel.findPostByPage(page) .then(result=&gt;&#123; //console.log(result) ctx.body = result &#125;).catch(()=&gt;&#123; ctx.body = 'error' &#125;) &#125;)// 个人文章分页，每次输出10条router.post('/posts/self/page', async(ctx, next) =&gt; &#123; let data = ctx.request.body await userModel.findPostByUserPage(data.name,data.page) .then(result=&gt;&#123; //console.log(result) ctx.body = result &#125;).catch(()=&gt;&#123; ctx.body = 'error' &#125;) &#125;)module.exports = router 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉 修改 views/posts.ejs 12345&lt;%- include(&quot;header&quot;,&#123;type:&apos;posts&apos;&#125;) %&gt; posts&lt;% include footer %&gt; 现在看看登录成功之后的页面吧 接下来我们实现登出页面 登出页面修改 router/signout.js signout.js123456789const router = require('koa-router')();router.get('/signout', async(ctx, next) =&gt; &#123; ctx.session = null; console.log('登出成功') ctx.body = true&#125;)module.exports = router 把session设置为null即可 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉，现在把注释的路由全部取消注释就对了 然后我们看看 views/header.ejs 我们点击登出后的ajax 的提交，成功之后回到posts页面 发表文章修改router/posts在后面增加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 发表文章页面router.get('/create', async(ctx, next) =&gt; &#123; await ctx.render('create', &#123; session: ctx.session, &#125;)&#125;)// post 发表文章router.post('/create', async(ctx, next) =&gt; &#123; let title = ctx.request.body.title, content = ctx.request.body.content, id = ctx.session.id, name = ctx.session.user, time = moment().format('YYYY-MM-DD HH:mm:ss'), avator, // 现在使用markdown不需要单独转义 newContent = content.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;), newTitle = title.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;); //console.log([name, newTitle, content, id, time]) await userModel.findUserData(ctx.session.user) .then(res =&gt; &#123; console.log(res[0]['avator']) avator = res[0]['avator'] &#125;) await userModel.insertPost([name, newTitle, md.render(content), content, id, time,avator]) .then(() =&gt; &#123; ctx.body = true &#125;).catch(() =&gt; &#123; ctx.body = false &#125;)&#125;) 修改 views/create.ejs create.ejs123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%- include("header",&#123;type:'create'&#125;) %&gt;&lt;div class="container"&gt; &lt;form style="width:100%" method="post" class="form create"&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder="请输入标题" type="text" name="title"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea placeholder="请输入内容" name="content" id="" cols="42" rows="10"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="submit"&gt;发表&lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; $('.submit').click(()=&gt;&#123; if ($('input[name=title]').val().trim() == '') &#123; fade('请输入标题') &#125;else if ($('textarea').val().trim() == '') &#123; fade('请输入内容') &#125;else&#123; $.ajax(&#123; url: "/create", data: $('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('发表成功') setTimeout(()=&gt;&#123; window.location.href="/posts" &#125;,1000) &#125;else&#123; fade('发表失败') &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在看看能不能发表吧 即使我们发表了文章，但是当前我们的posts的页面没有显示，因为还没有获取到数据 我们可以看我们之前写的代码 router.get(&#39;/posts&#39;, async(ctx, next) =&gt; {}路由1234567891011121314151617181920if (ctx.request.querystring) &#123; ...&#125;else &#123; await userModel.findPostByPage(1) .then(result =&gt; &#123; //console.log(result) res = result &#125;) await userModel.findAllPost() .then(result=&gt;&#123; postsLength = result.length &#125;) await ctx.render('posts', &#123; session: ctx.session, posts: res, postsLength: postsLength, postsPageLength: Math.ceil(postsLength / 10), &#125;) &#125; if前面这部分我们先不用管，后面会说。只需要看else后面的代码我们通过userModel.findPostByPage(1)来获取第一页的数据，然后查找所有文章的数量，最后除以10拿到首页文章的页数，把数据postsPageLength的值传给模板posts.ejs。这样就可以渲染出来了 修改 views/posts.ejs posts.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;%- include("header",&#123;type:'all'&#125;) %&gt; &lt;div class="container"&gt; &lt;ul class="posts"&gt; &lt;% posts.forEach(function(res)&#123; %&gt; &lt;li&gt; &lt;div class="author"&gt; &lt;span title="&lt;%= res.name %&gt;"&gt;&lt;a href="/posts?author=&lt;%= res.name %&gt; "&gt;author: &lt;%= res.name %&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;评论数：&lt;%= res.comments %&gt;&lt;/span&gt; &lt;span&gt;浏览量：&lt;%= res.pv %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="comment_pv"&gt; &lt;span&gt;&lt;%= res.moment %&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="/posts/&lt;%= res.id %&gt;"&gt; &lt;div class="title"&gt; &lt;img class="userAvator" src="images/&lt;%= res.avator %&gt;.png"&gt; &lt;%= res.title %&gt; &lt;/div&gt; &lt;div class="content markdown"&gt; &lt;%- res.content %&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt; &lt;div style="margin-top: 30px" class="pagination" id="page"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="http://www.wclimb.site/pagination/pagination.js"&gt;&lt;/script&gt; &lt;script&gt; pagination(&#123; selector: '#page', totalPage: &lt;%= postsPageLength %&gt;, currentPage: 1, prev: '上一页', next: '下一页', first: true, last: true, showTotalPage: true, count: 2//当前页前后显示的数量 &#125;,function(val)&#123; // 当前页 $.ajax(&#123; url: "posts/page", type: 'POST', data:&#123; page: val &#125;, cache: false, success: function (msg) &#123; console.log(msg) if (msg != 'error') &#123; $('.posts').html(' ') $.each(msg,function(i,val)&#123; //console.log(val.content) $('.posts').append( '&lt;li&gt;'+ '&lt;div class=\"author\"&gt;'+ '&lt;span title=\"'+ val.name +'\"&gt;&lt;a href=\"/posts?author='+ val.name +' \"&gt;author: '+ val.name +'&lt;/a&gt;&lt;/span&gt;'+ '&lt;span&gt;评论数：'+ val.comments +'&lt;/span&gt;'+ '&lt;span&gt;浏览量：'+ val.pv +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;div class=\"comment_pv\"&gt;'+ '&lt;span&gt;'+ val.moment +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;a href=\"/posts/'+ val.id +'\"&gt;'+ '&lt;div class=\"title\"&gt;'+ '&lt;img class="userAvator" src="images/'+ val.avator +'.png"&gt;'+ val.title + '&lt;/div&gt;'+ '&lt;div class=\"content\"&gt;'+ val.content + '&lt;/div&gt;'+ '&lt;/a&gt;'+ '&lt;/li&gt;' ) &#125;) &#125;else&#123; alert('分页不存在') &#125; &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 现在看看posts页面有没有文章出现了 我们看到是所第一页的文章数据，初始化的稍后我们是用服务端渲染的数据，使用了分页，每页显示10条数据，然后通过请求页数。下面是服务端请求拿到的第一页的数据1234await userModel.findPostByUserPage(name,1) .then(result =&gt; &#123; res = result &#125;) 要拿到别的页面数据的话要向服务器发送post请求，如下1234567891011// 首页分页，每次输出10条router.post(&apos;/posts/page&apos;, async(ctx, next) =&gt; &#123; let page = ctx.request.body.page; await userModel.findPostByPage(page) .then(result=&gt;&#123; //console.log(result) ctx.body = result &#125;).catch(()=&gt;&#123; ctx.body = &apos;error&apos; &#125;) &#125;) 单篇文章页面但是我需要点击单篇文章的时候，显示一篇文章怎么办呢？ 修改 routers/posts.js 在posts.js后面增加 12345678910111213141516171819202122232425262728293031323334// 单篇文章页router.get('/posts/:postId', async(ctx, next) =&gt; &#123; let comment_res, res, pageOne, res_pv; await userModel.findDataById(ctx.params.postId) .then(result =&gt; &#123; //console.log(result ) res = result res_pv = parseInt(result[0]['pv']) res_pv += 1 // console.log(res_pv) &#125;) await userModel.updatePostPv([res_pv, ctx.params.postId]) await userModel.findCommentByPage(1,ctx.params.postId) .then(result =&gt; &#123; pageOne = result //console.log('comment', comment_res) &#125;) await userModel.findCommentById(ctx.params.postId) .then(result =&gt; &#123; comment_res = result //console.log('comment', comment_res) &#125;) await ctx.render('sPost', &#123; session: ctx.session, posts: res[0], commentLenght: comment_res.length, commentPageLenght: Math.ceil(comment_res.length/10), pageOne:pageOne &#125;)&#125;) 现在的设计是，我们点进去出现的url是 /posts/1 这类的 1代表该篇文章的id，我们在数据库建表的时候就处理了，让id为主键，然后递增 我们通过userModel.findDataById 文章的id来查找数据库我们通过userModel.findCommentById 文章的id来查找文章的评论，因为单篇文章里面有评论的功能最后通过sPost.ejs模板渲染单篇文章 修改 views/sPost.ejs sPost.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186&lt;%- include("header",&#123;type:''&#125;) %&gt; &lt;div class="container"&gt; &lt;ul class="posts spost"&gt; &lt;li&gt; &lt;div class="author"&gt; &lt;span title="&lt;%= posts.name %&gt;"&gt;&lt;a href="/posts?author=&lt;%= posts.name %&gt; "&gt;author: &lt;%= posts.name %&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;评论数：&lt;%= posts.comments %&gt;&lt;/span&gt; &lt;span&gt;浏览量：&lt;%= posts.pv %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="comment_pv"&gt; &lt;span&gt;&lt;%= posts.moment %&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="/posts/&lt;%= posts.id %&gt;"&gt; &lt;div class="title"&gt; &lt;img class="userAvator" src="../images/&lt;%= posts.avator %&gt;.png"&gt; &lt;%= posts.title %&gt; &lt;/div&gt; &lt;div class="content markdown"&gt; &lt;%- posts.content %&gt; &lt;/div&gt; &lt;/a&gt; &lt;div class="edit"&gt; &lt;% if(session &amp;&amp; session.user === posts.name )&#123; %&gt; &lt;p&gt;&lt;a href="&lt;%= posts['id'] %&gt;/edit"&gt;编辑&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a class="delete_post"&gt;删除&lt;/a&gt;&lt;/p&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="comment_wrap"&gt; &lt;% if(session.user)&#123; %&gt; &lt;form class="form" method="post" action="/&lt;%= posts.id %&gt;"&gt; &lt;textarea id="spContent" name="content" cols="82"&gt;&lt;/textarea&gt; &lt;div class="submit"&gt;发表留言&lt;/div&gt; &lt;/form&gt; &lt;% &#125; else&#123; %&gt; &lt;p class="tips"&gt;登录之后才可以评论哟&lt;/p&gt; &lt;% &#125; %&gt; &lt;% if (commentPageLenght &gt; 0) &#123; %&gt; &lt;div class="comment_list markdown"&gt; &lt;% pageOne.forEach(function(res)&#123; %&gt; &lt;div class="cmt_lists"&gt; &lt;div class="cmt_content"&gt; &lt;div class="userMsg"&gt; &lt;img src="../images/&lt;%= res['avator'] %&gt;.png" alt=""&gt;&lt;span&gt;&lt;%= res['name'] %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="cmt_detail"&gt; &lt;%- res['content'] %&gt; &lt;/div&gt; &lt;span class="cmt_time"&gt;&lt;%= res['moment'] %&gt;&lt;/span&gt; &lt;span class="cmt_name"&gt; &lt;% if(session &amp;&amp; session.user === res['name'])&#123; %&gt; &lt;a class="delete_comment" href="javascript:delete_comment(&lt;%= res['id'] %&gt;);"&gt; 删除&lt;/a&gt; &lt;% &#125; %&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;% &#125; else&#123; %&gt; &lt;p class="tips"&gt;还没有评论，赶快去评论吧！&lt;/p&gt; &lt;% &#125; %&gt; &lt;div style="margin-top: 30px" class="pagination" id="page"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="http://www.wclimb.site/pagination/pagination.js"&gt;&lt;/script&gt; &lt;script&gt; var userName = "&lt;%- session.user %&gt;" pagination(&#123; selector: '#page', totalPage: &lt;%= commentPageLenght %&gt;, currentPage: 1, prev: '上一页', next: '下一页', first: true, last: true, showTotalPage:true, count: 2//当前页前面显示的数量 &#125;,function(val)&#123; // 当前页 var _comment = '' $.ajax(&#123; url: "&lt;%= posts.id %&gt;/commentPage", type: 'POST', data:&#123; page: val &#125;, cache: false, success: function (msg) &#123; //console.log(msg) _comment = '' if (msg != 'error') &#123; $('.comment_list').html(' ') $.each(msg,function(i,val)&#123; //console.log(val.content) _comment += '&lt;div class=\"cmt_lists\"&gt;&lt;div class=\"cmt_content\"&gt;&lt;div class=\"userMsg\"&gt;&lt;img src = \"../images/'+ val.avator +'.png\" &gt;&lt;span&gt;'+ val.name +'&lt;/span&gt;&lt;/div &gt;&lt;div class="cmt_detail"&gt;'+ val.content + '&lt;/div&gt;&lt;span class=\"cmt_time\"&gt;'+ val.moment +'&lt;/span&gt;&lt;span class=\"cmt_name\"&gt;'; if (val.name == userName) &#123; _comment += '&lt;a class=\"delete_comment\" href=\"javascript:delete_comment('+ val.id +');\"&gt; 删除&lt;/a&gt;' &#125; _comment += '&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;' &#125;) $('.comment_list').append(_comment) &#125;else&#123; alert('分页不存在') &#125; &#125; &#125;) &#125;) // 删除文章 $('.delete_post').click(() =&gt; &#123; $.ajax(&#123; url: "&lt;%= posts.id %&gt;/remove", type: 'POST', cache: false, success: function (msg) &#123; if (msg.data == 1) &#123; fade('删除文章成功') setTimeout(() =&gt; &#123; window.location.href = "/posts" &#125;, 1000) &#125; else if (msg.data == 2) &#123; fade('删除文章失败'); setTimeout(() =&gt; &#123; window.location.reload() &#125;, 1000) &#125; &#125; &#125;) &#125;) // 评论 var isAllow = true $('.submit').click(function()&#123; if (!isAllow) return isAllow = false if ($('textarea').val().trim() == '') &#123; fade('请输入评论！') &#125;else&#123; $.ajax(&#123; url: '/' + location.pathname.split('/')[2], data:$('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('发表留言成功') setTimeout(()=&gt;&#123; isAllow = true window.location.reload() &#125;,1500) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;) // 删除评论 function delete_comment(id) &#123; $.ajax(&#123; url: "&lt;%= posts.id %&gt;/comment/" + id + "/remove", type: 'POST', cache: false, success: function (msg) &#123; if (msg.data == 1) &#123; fade('删除留言成功') setTimeout(() =&gt; &#123; window.location.reload() &#125;, 1000) &#125; else if (msg.data == 2) &#123; fade('删除留言失败'); setTimeout(() =&gt; &#123; window.location.reload() &#125;, 1500) &#125; &#125;, error: function () &#123; alert('异常') &#125; &#125;) &#125; &lt;/script&gt;&lt;% include footer %&gt; 现在点击单篇文章试试，进入单篇文章页面，但是编辑、删除、评论都还没有做，点击无效，我们先不做，先实现每个用户自己发表的文章列表，我们之前在 get ‘/posts’ 里面说先忽略if (ctx.request.querystring) {}里面的代码，这里是做了一个处理，假如用户点击了某个用户，该用户发表了几篇文章，我们需要只显示该用户发表的文章，那么进入的url应该是 /posts?author=xxx ,这个处理在posts.ejs 就已经加上了，就在文章的左下角，作者：xxx就是一个链接。我们通过判断用户来查找文章，继而有了ctx.request.querystring 获取到的是：author=xxx 注：这里我们处理了，通过判断 session.user === res[&#39;name&#39;] 如果不是该用户发的文章，不能编辑和删除，评论也是。这里面也可以注意一下包裹的&lt;a href=&quot;&quot;&gt;&lt;/a&gt;标签 个人已发表文章列表里面还记得之前在 get ‘/post’ 里面的代码吗？下面的代码就是之前说先不处理的代码片段，不过这个不用再次添加，之前已经添加好了，这段代码处理个人发布的文章列表，我们是通过selfPosts.ejs模板来渲染的，样式和全部文章列表一样，但是牵扯到分页的问题，分页请求的是不同的接口地址 12345678910111213141516if (ctx.request.querystring) &#123; console.log('ctx.request.querystring', name) await userModel.findDataByUser(name) .then(result =&gt; &#123; postsLength = result.length &#125;) await userModel.findPostByUserPage(name,1) .then(result =&gt; &#123; res = result &#125;) await ctx.render('selfPosts', &#123; session: ctx.session, posts: res, postsPageLength:Math.ceil(postsLength / 10), &#125;) &#125; 修改 selfPost.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;%- include("header",&#123;type:'my'&#125;) %&gt; &lt;div class="container"&gt; &lt;ul class="posts"&gt; &lt;% posts.forEach(function(res)&#123; %&gt; &lt;li&gt; &lt;div class="author"&gt; &lt;span title="&lt;%= res.name %&gt;"&gt;&lt;a href="/posts?author=&lt;%= res.name %&gt; "&gt;author: &lt;%= res.name %&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;评论数：&lt;%= res.comments %&gt;&lt;/span&gt; &lt;span&gt;浏览量：&lt;%= res.pv %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="comment_pv"&gt; &lt;span&gt;&lt;%= res.moment %&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="/posts/&lt;%= res.id %&gt;"&gt; &lt;div class="title"&gt; &lt;img class="userAvator" src="images/&lt;%= res.avator %&gt;.png"&gt; &lt;%= res.title %&gt; &lt;/div&gt; &lt;div class="content markdown"&gt; &lt;%- res.content %&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt; &lt;div style="margin-top: 30px" class="pagination" id="page"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="http://www.wclimb.site/pagination/pagination.js"&gt;&lt;/script&gt; &lt;script&gt; pagination(&#123; selector: '#page', totalPage: &lt;%= postsPageLength %&gt;, currentPage: 1, prev: '上一页', next: '下一页', first: true, last: true, showTotalPage: true, count: 2//当前页前后显示的数量 &#125;,function(val)&#123; // 当前页 $.ajax(&#123; url: "posts/self/page", type: 'POST', data:&#123; page: val, name: location.search.slice(1).split('=')[1] &#125;, cache: false, success: function (msg) &#123; //console.log(msg) if (msg != 'error') &#123; $('.posts').html(' ') $.each(msg,function(i,val)&#123; //console.log(val.content) $('.posts').append( '&lt;li&gt;'+ '&lt;div class=\"author\"&gt;'+ '&lt;span title=\"'+ val.name +'\"&gt;&lt;a href=\"/posts?author='+ val.name +' \"&gt;author: '+ val.name +'&lt;/a&gt;&lt;/span&gt;'+ '&lt;span&gt;评论数：'+ val.comments +'&lt;/span&gt;'+ '&lt;span&gt;浏览量：'+ val.pv +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;div class=\"comment_pv\"&gt;'+ '&lt;span&gt;'+ val.moment +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;a href=\"/posts/'+ val.id +'\"&gt;'+ '&lt;div class=\"title\"&gt;'+ '&lt;img class="userAvator" src="images/' + val.avator + '.png"&gt;' + val.title + '&lt;/div&gt;'+ '&lt;div class=\"content\"&gt;'+ val.content + '&lt;/div&gt;'+ '&lt;/a&gt;'+ '&lt;/li&gt;' ) &#125;) &#125;else&#123; alert('分页不存在') &#125; &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 编辑文章、删除文章、评论、删除评论 评论 修改routers/posts.js 在post.js 后面增加 12345678910111213141516171819202122232425262728293031323334353637// 发表评论router.post('/:postId', async(ctx, next) =&gt; &#123; let name = ctx.session.user, content = ctx.request.body.content, postId = ctx.params.postId, res_comments, time = moment().format('YYYY-MM-DD HH:mm:ss'), avator; await userModel.findUserData(ctx.session.user) .then(res =&gt; &#123; console.log(res[0]['avator']) avator = res[0]['avator'] &#125;) await userModel.insertComment([name, md.render(content),time, postId,avator]) await userModel.findDataById(postId) .then(result =&gt; &#123; res_comments = parseInt(result[0]['comments']) res_comments += 1 &#125;) await userModel.updatePostComment([res_comments, postId]) .then(() =&gt; &#123; ctx.body = true &#125;).catch(() =&gt; &#123; ctx.body = false &#125;)&#125;)// 评论分页router.post('/posts/:postId/commentPage', async function(ctx)&#123; let postId = ctx.params.postId, page = ctx.request.body.page; await userModel.findCommentByPage(page,postId) .then(res=&gt;&#123; ctx.body = res &#125;).catch(()=&gt;&#123; ctx.body = 'error' &#125;) &#125;) 现在试试发表评论的功能吧，之所以这样简单，因为我们之前就在sPost.ejs做了好几个ajax的处理，删除文章和评论也是如此评论我们也做了分页，所以后面会有一个评论的分页的接口，我们已经在sPost.ejs里面写好了ajax请求 删除评论 修改routers/posts.js 继续在post.js 后面增加 12345678910111213141516171819202122232425// 删除评论router.post('/posts/:postId/comment/:commentId/remove', async(ctx, next) =&gt; &#123; let postId = ctx.params.postId, commentId = ctx.params.commentId, res_comments; await userModel.findDataById(postId) .then(result =&gt; &#123; res_comments = parseInt(result[0]['comments']) //console.log('res', res_comments) res_comments -= 1 //console.log(res_comments) &#125;) await userModel.updatePostComment([res_comments, postId]) await userModel.deleteComment(commentId) .then(() =&gt; &#123; ctx.body = &#123; data: 1 &#125; &#125;).catch(() =&gt; &#123; ctx.body = &#123; data: 2 &#125; &#125;)&#125;) 现在试试删除评论的功能吧 删除文章 只有自己发表的文字删除的文字才会显示出来，才能被删除， 修改routers/posts.js 继续在post.js 后面增加 123456789101112131415// 删除单篇文章router.post('/posts/:postId/remove', async(ctx, next) =&gt; &#123; let postId = ctx.params.postId await userModel.deleteAllPostComment(postId) await userModel.deletePost(postId) .then(() =&gt; &#123; ctx.body = &#123; data: 1 &#125; &#125;).catch(() =&gt; &#123; ctx.body = &#123; data: 2 &#125; &#125;)&#125;) 现在试试删除文章的功能吧 编辑文章 修改routers/posts.js 继续在post.js 后面增加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 编辑单篇文章页面router.get('/posts/:postId/edit', async(ctx, next) =&gt; &#123; let name = ctx.session.user, postId = ctx.params.postId, res; await userModel.findDataById(postId) .then(result =&gt; &#123; res = result[0] //console.log('修改文章', res) &#125;) await ctx.render('edit', &#123; session: ctx.session, postsContent: res.md, postsTitle: res.title &#125;)&#125;)// post 编辑单篇文章router.post('/posts/:postId/edit', async(ctx, next) =&gt; &#123; let title = ctx.request.body.title, content = ctx.request.body.content, id = ctx.session.id, postId = ctx.params.postId, // 现在使用markdown不需要单独转义 newTitle = title.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;), newContent = content.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;); await userModel.updatePost([newTitle, md.render(content), content, postId]) .then(() =&gt; &#123; ctx.body = true &#125;).catch(() =&gt; &#123; ctx.body = false &#125;)&#125;) 修改views/edit.js 12345678910111213141516171819202122232425262728293031323334353637&lt;%- include("header",&#123;type:''&#125;) %&gt;&lt;div class="container"&gt; &lt;form style="width:100%" class="form create" method="post"&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder="标题" type="text" name="title" value="&lt;%- postsTitle %&gt;"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea name="content" id="" cols="42" rows="10"&gt;&lt;%= postsContent %&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="submit"&gt;修改&lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; $('.submit').click(()=&gt;&#123; $.ajax(&#123; url: '', data: $('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('修改成功') setTimeout(()=&gt;&#123; window.location.href="/posts" &#125;,1000) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在试试编辑文字然后修改提交吧 结语至此一个简单的blog就已经制作好了，其他扩展功能相信你已经会了吧！如果出现问题，还望积极提问哈，我会尽快处理的 所有的代码都在 https://github.com/wclimb/Koa2-blog 里面，如果觉得不错就star一下吧。有问题可以提问哟下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^ 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>Node</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（一）]]></title>
    <url>%2F2017%2F06%2F29%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 读zepto源码，封装自己的zepto库系列是自己在读zepto源码的一些理解，有错误的地方还望指出。如果觉得本系列对你有所帮助，还请持续关注wclimb，谢谢。 zepto的整体架构首先来看看整体代码结构 123456789101112131415161718192021222324252627282930313233(function()&#123; var wclimb = &#123;&#125;,$ $ = function(selector)&#123; return wclimb.init(selector) &#125; wclimb.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wclimb.Z(dom,selector) &#125; wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wclimb.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wclimb = $&#125;)() 首先我们设置了一个闭包，避免产生全局变量123(function()&#123; ...&#125;)() 我们定义一个对象wclimb和$，以便后面使用 1var wclimb = &#123;&#125;,$ $函数返回了wclimb.init(selector),我们知道使用zepto的时候，一般是$(‘p’)，而selector就是p元素，当然不止这一种情况如$(function(){}),所以对选择器后面我们要做判断123$ = function(selector)&#123; return wclimb.init(selector)&#125; 而wclimb.init首先定义了一个dom，通过选择器选取的元素赋值给dom，最后返回wclimb.init，传入dom和选择元素selector 12345wclimb.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector)&#125; 我们可以看到之前我们定义了对象wclimb，而后我们就往里面添加了一些方法，就像： 12345678910wclimb = &#123; init：function(selector)&#123; var dom; dom = document.querySelector(selector); return wclimb.Z(dom,selector) &#125;, Z: function(dom,selector)&#123; return new Z(dom,selector) &#125;&#125; 通过wclimb.Z，如果有看过zepto源码的同学应该对此有了解.每次用$调用的时候,将直接返回一个Z的实例.达到无new调用的效果,$(‘p’)返回一个实例，然后$(‘p’).test()调用他的原形方法，这里的方法是test 1234567891011wclimb.Z = function(dom,selector)&#123; return new Z(dom,selector)&#125;function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 由于我们是return new Z(dom,selector),那自然,我们需要手动的把wclimb.Z的prototype指向Z的prototype 123456789wclimb.Z.prototype = Z.prototype&#123;&#125;我们可以在里面添加方法了，如addClass eq等，我们试试加一个testwclimb.Z.prototype = Z.prototype&#123; test: function()&#123; console.log('test') &#125;&#125; Z函数是这样的，因为我们选择器选择的元素是一个数组（其实不是）我们把this指向选择的元素，然后添加两个元素selector和length，分别代表选择的元素名和元素的长度 1234567function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 最后我们在window上对外暴露一个接口,我们就可以用 $(‘p’) 或者wclimb(‘p’) 即可调用. 1window.$ = window.wclimb = $ 现在可以试试能不能运行 123html：&lt;p&gt;test&lt;/p&gt;js：$('p') 调用方法试试 $('p').test() 我们的zepto已经完成了，是不是很简单？骗你的，还差得远呢，后面会慢慢完善。待续。。。如果你觉得该文章帮助到了你，不妨star一下https://github.com/wclimb/wclimb.github.io ，感谢]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>原创</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas仿微信红包照片]]></title>
    <url>%2F2017%2F06%2F28%2Fcanvas%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[canvas仿微信红包照片 By wclimbHTML1&lt;canvas id=&quot;cav&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; CSS 设置canvas的背景图 1234canvas&#123; background:url(https://b-ssl.duitang.com/uploads/item/201501/22/20150122203239_Cfr58.thumb.700_0.jpeg) no-repeat; background-size:100% 100%;&#125; JS12345678910111213141516171819202122232425262728293031323334353637var canvas = document.querySelector("#cav")var context = canvas.getContext("2d");var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30)context.globalAlpha = 0.96;context.fillStyle = '#333'context.rect(0,0,canvas.width,canvas.height);context.fill();context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore();var num = 30;var time = null;document.body.onclick = function()&#123; function circle()&#123; num += 5 context.save() context.beginPath() context.arc(randomX,randomY,num,0,Math.PI*2,false); context.clip(); context.clearRect(0,0,canvas.width,canvas.height) context.restore(); console.log(num) if (num &gt;= 677)&#123; clearInterval(timer) &#125; &#125; timer = setInterval(circle,10)&#125; 解析 随机出现圆心的位置，因为canvas为500*500 圆心为30 所以圆心的范围为 X(30,470) Y(470,30) 12var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30) 绘制矩形 透明度为0.96 填充颜色#333 宽高为canvas的宽高 最后用fill填充 1234context.globalAlpha = 0.96;context.fillStyle = '#333'context.rect(0,0,canvas.width,canvas.height);context.fill(); 初始化圆心的位置，用arc绘制圆，默认半径为30，用clip剪切，只有被剪切区域内是可见的 123456context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore(); 点击body的时候，设置定时器，让圆的半径每隔10毫秒增加5，当num半径大于677关闭定时器，677为canvas对角的长度 1document.body.onclick = function()&#123;&#125; 效果预览]]></content>
      <categories>
        <category>javascript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp基础教程]]></title>
    <url>%2F2017%2F06%2F27%2Fgulp%2F</url>
    <content type="text"><![CDATA[入门指南–引用gulp官网示例 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 12345var gulp = require('gulp');gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp 1$ gulp //默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 至此，一个简单的gulp已经完成，接下来让我们来完善部分功能 gulp功能完善生成package.json文件1$ npm init //一直回车，有需要的可以设置 安装所需包 使用淘宝镜像 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org示例 $ cnpm install [name] 接着1$ cnpm i browser-sync gulp gulp-clean-css gulp-imagemin gulp-rename gulp-sass gulp-uglify gulp.spritesmith gulp-autoprefixer --save 新建gulpfile.js文件添加123456789var gulp = require('gulp'); var browserSync = require('browser-sync').create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require('gulp-sass'); //sass转cssvar reload = browserSync.reload; var minifyCSS = require('gulp-clean-css') //css压缩var uglify = require('gulp-uglify') //js压缩var imagemin = require('gulp-imagemin') //图片压缩var rename = require('gulp-rename') //文件重命名var autoprefixer = require('gulp-autoprefixer') //自动添加前缀 设置默认文件地址12345678code为文件夹，里面存放html css js文件var src = &#123; scss: 'code/scss/*.scss', css: 'code/css/*.css', html: 'code/*.html', js: 'code/js/*.js', images: 'code/images/*.&#123;png,jpg,gif,ico&#125;'&#125;; gulp.task(name[, deps], fn)1234567891011121314151617name: 任务的名字deps: 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。// 静态服务器 + 监听 scss/html 文件 gulp.task('serve', ['sass'], function() &#123; browserSync.init(&#123; server: "./code" &#125;); gulp.watch(src.scss, ['sass']); gulp.watch(src.css, ['css']); gulp.watch(src.images, ['images']) gulp.watch(src.js, ['js']); gulp.watch(src.html).on('change', reload);&#125;); scss编译后的css将注入到浏览器里实现更新123456789101112131415gulp.task('sass', function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: 'ie7',//保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) .pipe(reload(&#123;stream: true&#125;));&#125;); 雪碧图（有需要可以尝试）123456789101112var spritesmith = require('gulp.spritesmith'); gulp.task('sprite', function () &#123; return gulp.src('code/images/*.png') .pipe(spritesmith(&#123; imgName:'images/sprite20161010.png', //保存合并后图片的地址 cssName:'css/sprite.css', //保存合并后对于css样式的地址 padding:20, algorithm:'binary-tree', &#125;)) .pipe(gulp.dest('code/scss')); &#125;); 监听css文件1234567gulp.task('css', function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) .pipe(reload(&#123;stream: true&#125;));&#125;); 监听js文件12345678910gulp.task('js', function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: '.min'&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest('code/dest')) .pipe(reload(&#123;stream: true&#125;));&#125;) 压缩图片任务12345678910// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest('images')) .pipe(reload(&#123;stream: true&#125;));&#125;); 最后控制台输入gulp执行1gulp.task('default', ['serve']); 如果觉得帮助到了你，欢迎star -&gt; https://github.com/wclimb/wclimb.github.io 完整代码文件目录123456789101112-code -imgage 1.png -css default.css -scss default.scss -js default.js index.htmlgulpfile.jspackage.json package.json12345678910111213141516171819202122232425&#123; "name": "gulp-test", "version": "1.0.0", "description": "Gulp &amp; SASS", "main": "gulpfile.js", "scripts": &#123; "start": "gulp" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "browser-sync": "^2.2.0", "gulp": "^3.9.1", "gulp-clean-css": "^3.0.3", "gulp-imagemin": "^3.1.1", "gulp-rename": "^1.2.2", "gulp-sass": "^3.1.0", "gulp-uglify": "^2.0.1", "gulp.spritesmith": "^6.4.0", "gulp-autoprefixer": "^4.0.0" &#125;, "dependencies": &#123; &#125;&#125; gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103var gulp = require('gulp'); var browserSync = require('browser-sync').create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require('gulp-sass'); //sass转cssvar reload = browserSync.reload; var minifyCSS = require('gulp-clean-css') //css压缩var uglify = require('gulp-uglify') //js压缩var imagemin = require('gulp-imagemin') //图片压缩var rename = require('gulp-rename') //文件重命名var autoprefixer = require('gulp-autoprefixer') //自动添加前缀var src = &#123; scss: 'code/scss/*.scss', css: 'code/css/*.css', html: 'code/*.html', js: 'code/js/*.js', images: 'code/images/*.&#123;png,jpg,gif,ico&#125;'&#125;;// 静态服务器 + 监听 scss/html 文件 gulp.task('serve', ['sass'], function() &#123; browserSync.init(&#123; server: "./code" &#125;); gulp.watch(src.scss, ['sass']); gulp.watch(src.css, ['css']); gulp.watch(src.images, ['images']) gulp.watch(src.js, ['js']); gulp.watch(src.html).on('change', reload);&#125;);// scss编译后的css将注入到浏览器里实现更新gulp.task('sass', function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: 'ie7',//保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) //重新输出数据到某个文件夹，如果没有就会自动创建 .pipe(reload(&#123;stream: true&#125;));&#125;);// 雪碧图（有需要可以尝试）//var spritesmith = require('gulp.spritesmith'); // gulp.task('sprite', function () &#123;// return gulp.src('code/images/*.png')// .pipe(spritesmith(&#123;// imgName:'images/sprite20161010.png', //保存合并后图片的地址// cssName:'css/sprite.css', //保存合并后对于css样式的地址// padding:20,// algorithm:'binary-tree',// &#125;))// .pipe(gulp.dest('code/scss'));// &#125;);gulp.task('css', function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task('js', function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: '.min'&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest('code/dest')) .pipe(reload(&#123;stream: true&#125;));&#125;)// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest('images')) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task('default', ['serve']);]]></content>
      <categories>
        <category>javascript</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>
